<?xml version="1.0"?>
<doc>
    <assembly>
        <name>LibHac</name>
    </assembly>
    <members>
        <member name="P:LibHac.Bcat.ResultBcat.InvalidArgument">
            <summary>Error code: 2122-0001; Inner value: 0x27a</summary>
        </member>
        <member name="P:LibHac.Bcat.ResultBcat.NotFound">
            <summary>Error code: 2122-0002; Inner value: 0x47a</summary>
        </member>
        <member name="P:LibHac.Bcat.ResultBcat.TargetLocked">
            <summary>Error code: 2122-0003; Inner value: 0x67a</summary>
        </member>
        <member name="P:LibHac.Bcat.ResultBcat.TargetAlreadyMounted">
            <summary>Error code: 2122-0004; Inner value: 0x87a</summary>
        </member>
        <member name="P:LibHac.Bcat.ResultBcat.TargetNotMounted">
            <summary>Error code: 2122-0005; Inner value: 0xa7a</summary>
        </member>
        <member name="P:LibHac.Bcat.ResultBcat.AlreadyOpen">
            <summary>Error code: 2122-0006; Inner value: 0xc7a</summary>
        </member>
        <member name="P:LibHac.Bcat.ResultBcat.NotOpen">
            <summary>Error code: 2122-0007; Inner value: 0xe7a</summary>
        </member>
        <member name="P:LibHac.Bcat.ResultBcat.InternetRequestDenied">
            <summary>Error code: 2122-0008; Inner value: 0x107a</summary>
        </member>
        <member name="P:LibHac.Bcat.ResultBcat.ServiceOpenLimitReached">
            <summary>Error code: 2122-0009; Inner value: 0x127a</summary>
        </member>
        <member name="P:LibHac.Bcat.ResultBcat.SaveDataNotFound">
            <summary>Error code: 2122-0010; Inner value: 0x147a</summary>
        </member>
        <member name="P:LibHac.Bcat.ResultBcat.NetworkServiceAccountNotAvailable">
            <summary>Error code: 2122-0031; Inner value: 0x3e7a</summary>
        </member>
        <member name="P:LibHac.Bcat.ResultBcat.PassphrasePathNotFound">
            <summary>Error code: 2122-0080; Inner value: 0xa07a</summary>
        </member>
        <member name="P:LibHac.Bcat.ResultBcat.DataVerificationFailed">
            <summary>Error code: 2122-0081; Inner value: 0xa27a</summary>
        </member>
        <member name="P:LibHac.Bcat.ResultBcat.PermissionDenied">
            <summary>Error code: 2122-0090; Inner value: 0xb47a</summary>
        </member>
        <member name="P:LibHac.Bcat.ResultBcat.AllocationFailed">
            <summary>Error code: 2122-0091; Inner value: 0xb67a</summary>
        </member>
        <member name="P:LibHac.Bcat.ResultBcat.InvalidOperation">
            <summary>Error code: 2122-0098; Inner value: 0xc47a</summary>
        </member>
        <member name="P:LibHac.Bcat.ResultBcat.InvalidDeliveryCacheStorageFile">
            <summary>Error code: 2122-0204; Inner value: 0x1987a</summary>
        </member>
        <member name="P:LibHac.Bcat.ResultBcat.StorageOpenLimitReached">
            <summary>Error code: 2122-0205; Inner value: 0x19a7a</summary>
        </member>
        <member name="T:LibHac.BitReader.OffsetBias">
            <summary>
            Specifies the bias of an offset binary value. A positive bias can represent one more
            positive value than negative value, and a negative bias can represent one more
            negative value than positive value.
            </summary>
            <remarks>Example:
            A 4-bit offset binary value with a positive bias can store
            the values 8 through -7 inclusive.
            A 4-bit offset binary value with a negative bias can store
            the values 7 through -8 inclusive.</remarks>
        </member>
        <member name="T:LibHac.Boot.Package2StorageReader">
            <summary>
            Parses a package2 file and opens the payloads within.
            </summary>
        </member>
        <member name="M:LibHac.Boot.Package2StorageReader.Initialize(LibHac.Keyset,LibHac.Fs.IStorage)">
            <summary>
            Initializes the <see cref="T:LibHac.Boot.Package2StorageReader"/>.
            </summary>
            <param name="keyset">The keyset to use for decrypting the package.</param>
            <param name="storage">An <see cref="T:LibHac.Fs.IStorage"/> of the encrypted package2.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.Boot.Package2StorageReader.OpenPayload(LibHac.Fs.IStorage@,System.Int32)">
            <summary>
            Opens a decrypted <see cref="T:LibHac.Fs.IStorage"/> of one of the payloads in the package.
            </summary>
            <param name="payloadStorage">If the method returns successfully, contains an <see cref="T:LibHac.Fs.IStorage"/>
            of the specified payload.</param>
            <param name="index">The index of the payload to get. Must me less than <see cref="F:LibHac.Boot.Package2Header.PayloadCount"/></param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.Boot.Package2StorageReader.OpenKernel(LibHac.Fs.IStorage@)">
            <summary>
            Opens an <see cref="T:LibHac.Fs.IStorage"/> of the kernel payload.
            </summary>
            <param name="kernelStorage">If the method returns successfully, contains an <see cref="T:LibHac.Fs.IStorage"/>
            of the kernel payload.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.Boot.Package2StorageReader.OpenIni(LibHac.Fs.IStorage@)">
            <summary>
            Opens an <see cref="T:LibHac.Fs.IStorage"/> of the initial process binary. If the binary is embedded in
            the kernel, this method will attempt to locate and return the embedded binary.
            </summary>
            <param name="iniStorage">If the method returns successfully, contains an <see cref="T:LibHac.Fs.IStorage"/>
            of the initial process binary.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.Boot.Package2StorageReader.Verify">
            <summary>
            Verifies the signature, metadata and payloads in the package.
            </summary>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.Boot.Package2StorageReader.VerifySignature">
            <summary>
            Verifies the signature of the package.
            </summary>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.
            <see cref="P:LibHac.Result.Success"/> if the signature is valid.</returns>
        </member>
        <member name="M:LibHac.Boot.Package2StorageReader.VerifyMeta">
            <summary>
            Verifies the package metadata.
            </summary>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.
            <see cref="P:LibHac.Result.Success"/> if the metadata is valid.</returns>
        </member>
        <member name="M:LibHac.Boot.Package2StorageReader.VerifyPayloads">
            <summary>
            Verifies the hashes of all the payloads in the metadata.
            </summary>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.
            <see cref="P:LibHac.Result.Success"/> if all the hashes are valid.</returns>
        </member>
        <member name="M:LibHac.Boot.Package2StorageReader.OpenDecryptedPackage(LibHac.Fs.IStorage@)">
            <summary>
            Opens a decrypted <see cref="T:LibHac.Fs.IStorage"/> of the entire package.
            </summary>
            <param name="packageStorage">If the method returns successfully, contains a decrypted
            <see cref="T:LibHac.Fs.IStorage"/> of the package.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="T:LibHac.Common.BlitSpan`1">
            <summary>
            Provides a representation of a region of memory as if it were a series of blittable structs
            of type <typeparamref name="T"/>. Also allows viewing the memory as a <see cref="T:System.Span`1"/> of bytes.
            </summary>
            <typeparam name="T">The element type.</typeparam>
        </member>
        <member name="P:LibHac.Common.BlitSpan`1.Length">
            <summary>
            The number of elements of type <typeparamref name="T"/> in the <see cref="T:LibHac.Common.BlitSpan`1"/>.
            </summary>
        </member>
        <member name="P:LibHac.Common.BlitSpan`1.Value">
            <summary>
            A reference to the first element in this collection.
            </summary>
        </member>
        <member name="P:LibHac.Common.BlitSpan`1.Item(System.Int32)">
            <summary>
            A reference to the element at index <paramref name="index"/>.
            </summary>
        </member>
        <member name="M:LibHac.Common.BlitSpan`1.#ctor(System.Span{`0})">
            <summary>
            Creates a new <see cref="T:LibHac.Common.BlitSpan`1"/> using the provided <see cref="T:System.Span`1"/>.
            </summary>
            <param name="data">The span from which to create the <see cref="T:LibHac.Common.BlitSpan`1"/>.
            Must have a length of at least 1.</param>
        </member>
        <member name="M:LibHac.Common.BlitSpan`1.#ctor(System.Span{System.Byte})">
            <summary>
            Creates a new <see cref="T:LibHac.Common.BlitSpan`1"/> using the provided <see cref="T:System.Span`1"/> of bytes.
            </summary>
            <param name="data">The byte span from which to create the <see cref="T:LibHac.Common.BlitSpan`1"/>.
            Must be long enough to hold at least one struct of type <typeparamref name="T"/></param>
        </member>
        <member name="M:LibHac.Common.BlitSpan`1.#ctor(`0@)">
            <summary>
            Creates a new <see cref="T:LibHac.Common.BlitSpan`1"/> over a struct of type <typeparamref name="T"/>.
            </summary>
            <param name="data">The struct from which to create the <see cref="T:LibHac.Common.BlitSpan`1"/>.</param>
        </member>
        <member name="P:LibHac.Common.BlitSpan`1.Span">
            <summary>
            A <see cref="T:System.Span`1"/> of the elements in the <see cref="T:LibHac.Common.BlitSpan`1"/>.
            </summary>
        </member>
        <member name="M:LibHac.Common.BlitSpan`1.GetByteSpan">
            <summary>
            Returns a view of the <see cref="T:LibHac.Common.BlitSpan`1"/> as a <see cref="T:System.Span`1"/> of bytes.
            </summary>
            <returns>A byte span representation of the <see cref="T:LibHac.Common.BlitSpan`1"/>.</returns>
        </member>
        <member name="M:LibHac.Common.BlitSpan`1.GetByteSpan(System.Int32)">
            <summary>
            Returns a view of the element at index <paramref name="elementIndex"/> as a <see cref="T:System.Span`1"/> of bytes.
            </summary>
            <param name="elementIndex">The zero-based index of the element.</param>
            <returns>A byte span representation of the element.</returns>
        </member>
        <member name="M:LibHac.Common.BlitSpan`1.QueryByteLength(System.Int32)">
            <summary>
            Calculates the length of memory in bytes that would be needed to store <paramref name="elementCount"/>
            elements of type <typeparamref name="T"/>.
            </summary>
            <param name="elementCount">The number of elements.</param>
            <returns>The number of bytes required.</returns>
        </member>
        <member name="T:LibHac.Common.BlitStruct`1">
            <summary>
            Handles storing a blittable struct or a series of blittable structs in a byte array.
            </summary>
            <typeparam name="T">The element type.</typeparam>
        </member>
        <member name="P:LibHac.Common.BlitStruct`1.Value">
            <summary>
            A reference to the first element in this collection.
            </summary>
        </member>
        <member name="M:LibHac.Common.BlitStruct`1.#ctor(System.Int32)">
            <summary>
            Initializes a new <see cref="T:LibHac.Common.BlitStruct`1"/> that can hold the specified number
            of elements of type <typeparamref name="T"/>.
            </summary>
            <param name="elementCount">The number of elements the <see cref="T:LibHac.Common.BlitStruct`1"/> will be able to store.</param>
        </member>
        <member name="P:LibHac.Common.BlitStruct`1.Span">
            <summary>
            Returns a <see cref="P:LibHac.Common.BlitStruct`1.Span"/> view of the elements in the current <see cref="T:LibHac.Common.BlitStruct`1"/> as type <typeparamref name="T"/>.
            </summary>
        </member>
        <member name="P:LibHac.Common.BlitStruct`1.ByteSpan">
            <summary>
            Returns a <see cref="P:LibHac.Common.BlitStruct`1.Span"/> view of the elements in the current <see cref="T:LibHac.Common.BlitStruct`1"/> as <see cref="T:System.Byte"/>s.
            </summary>
        </member>
        <member name="P:LibHac.Common.BlitStruct`1.BlitSpan">
            <summary>
            Creates a <see cref="T:LibHac.Common.BlitSpan`1"/> from the current <see cref="T:LibHac.Common.BlitStruct`1"/>.
            </summary>
        </member>
        <member name="M:LibHac.Common.BlitStruct`1.QueryByteLength(System.Int32)">
            <summary>
            Calculates the length of memory in bytes that would be needed to store <paramref name="elementCount"/>
            elements of type <typeparamref name="T"/>.
            </summary>
            <param name="elementCount">The number of elements.</param>
            <returns>The number of bytes required.</returns>
        </member>
        <member name="T:LibHac.Common.Buffer16">
            <summary>
            Represents a buffer of 16 bytes.
            Contains functions that assist with common operations on small buffers.
            </summary>
        </member>
        <member name="T:LibHac.Common.Id128">
            <summary>
            A generic 128-bit ID value.
            </summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.InvalidArgument">
            <summary>Error code: 2428-0001; Range: 1-49; Inner value: 0x3ac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.NullArgument">
            <summary>Error code: 2428-0002; Inner value: 0x5ac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.ArgumentOutOfRange">
            <summary>Error code: 2428-0003; Inner value: 0x7ac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.BufferTooSmall">
            <summary>Error code: 2428-0004; Inner value: 0x9ac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.ServiceNotInitialized">
            <summary>Error code: 2428-0051; Inner value: 0x67ac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.NotImplemented">
            <summary>Error code: 2428-0101; Inner value: 0xcbac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.InvalidData">
            <summary>Error code: 2428-1000; Range: 1000-1999; Inner value: 0x7d1ac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.InvalidInitialProcessData">
            <summary>Error code: 2428-1001; Range: 1001-1019; Inner value: 0x7d3ac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.InvalidKip">
            <summary>Error code: 2428-1002; Range: 1002-1009; Inner value: 0x7d5ac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.InvalidKipFileSize">
            <summary>The size of the KIP file was smaller than expected.<br/>Error code: 2428-1003; Inner value: 0x7d7ac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.InvalidKipMagic">
            <summary>The magic value of the KIP file was not KIP1.<br/>Error code: 2428-1004; Inner value: 0x7d9ac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.InvalidKipSegmentSize">
            <summary>The size of the compressed KIP segment was smaller than expected.<br/>Error code: 2428-1005; Inner value: 0x7dbac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.KipSegmentDecompressionFailed">
            <summary>An error occurred while decompressing a KIP segment.<br/>Error code: 2428-1006; Inner value: 0x7ddac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.InvalidIni">
            <summary>Error code: 2428-1010; Range: 1010-1019; Inner value: 0x7e5ac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.InvalidIniFileSize">
            <summary>The size of the INI file was smaller than expected.<br/>Error code: 2428-1011; Inner value: 0x7e7ac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.InvalidIniMagic">
            <summary>The magic value of the INI file was not INI1.<br/>Error code: 2428-1012; Inner value: 0x7e9ac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.InvalidIniProcessCount">
            <summary>The INI had an invalid process count.<br/>Error code: 2428-1013; Inner value: 0x7ebac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.InvalidPackage2">
            <summary>Error code: 2428-1020; Range: 1020-1039; Inner value: 0x7f9ac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.InvalidPackage2HeaderSignature">
            <summary>Error code: 2428-1021; Inner value: 0x7fbac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.InvalidPackage2MetaSizeA">
            <summary>Error code: 2428-1022; Inner value: 0x7fdac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.InvalidPackage2MetaSizeB">
            <summary>Error code: 2428-1023; Inner value: 0x7ffac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.InvalidPackage2MetaKeyGeneration">
            <summary>Error code: 2428-1024; Inner value: 0x801ac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.InvalidPackage2MetaMagic">
            <summary>Error code: 2428-1025; Inner value: 0x803ac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.InvalidPackage2MetaEntryPointAlignment">
            <summary>Error code: 2428-1026; Inner value: 0x805ac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.InvalidPackage2MetaPayloadAlignment">
            <summary>Error code: 2428-1027; Inner value: 0x807ac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.InvalidPackage2MetaPayloadSizeAlignment">
            <summary>Error code: 2428-1028; Inner value: 0x809ac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.InvalidPackage2MetaTotalSize">
            <summary>Error code: 2428-1029; Inner value: 0x80bac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.InvalidPackage2MetaPayloadSize">
            <summary>Error code: 2428-1030; Inner value: 0x80dac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.InvalidPackage2MetaPayloadsOverlap">
            <summary>Error code: 2428-1031; Inner value: 0x80fac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.InvalidPackage2MetaEntryPointNotFound">
            <summary>Error code: 2428-1032; Inner value: 0x811ac</summary>
        </member>
        <member name="P:LibHac.Common.ResultLibHac.InvalidPackage2PayloadCorrupted">
            <summary>Error code: 2428-1033; Inner value: 0x813ac</summary>
        </member>
        <member name="M:LibHac.Common.StringUtils.Concat(System.Span{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            Concatenates 2 byte strings.
            </summary>
            <param name="dest"></param>
            <param name="source"></param>
            <returns>The length of the resulting string.</returns>
            <remarks>This function appends the source string to the end of the null-terminated destination string.
            If the destination buffer is not large enough to contain the resulting string,
            bytes from the source string will be appended to the destination string util the buffer is full.
            If the length of the final string is the same length of the destination buffer,
            no null terminating byte will be written to the end of the string.</remarks>
        </member>
        <member name="M:LibHac.Common.U8Span.IsNull">
            <summary>
            Checks if the <see cref="T:LibHac.Common.U8Span"/> has no buffer.
            </summary>
            <returns><see langword="true"/> if the span has no buffer.
            Otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:LibHac.Common.U8Span.IsEmpty">
            <summary>
            Checks if the <see cref="T:LibHac.Common.U8Span"/> has no buffer or begins with a null terminator.
            </summary>
            <returns><see langword="true"/> if the span has no buffer or begins with a null terminator.
            Otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:LibHac.Common.U8SpanMutable.IsNull">
            <summary>
            Checks if the <see cref="T:LibHac.Common.U8StringMutable"/> has no buffer.
            </summary>
            <returns><see langword="true"/> if the span has no buffer.
            Otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:LibHac.Common.U8SpanMutable.IsEmpty">
            <summary>
            Checks if the <see cref="T:LibHac.Common.U8StringMutable"/> has no buffer or begins with a null terminator.
            </summary>
            <returns><see langword="true"/> if the span has no buffer or begins with a null terminator.
            Otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:LibHac.Common.U8String.IsNull">
            <summary>
            Checks if the <see cref="T:LibHac.Common.U8String"/> has no buffer.
            </summary>
            <returns><see langword="true"/> if the string has no buffer.
            Otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:LibHac.Common.U8String.IsEmpty">
            <summary>
            Checks if the <see cref="T:LibHac.Common.U8String"/> has no buffer or begins with a null terminator.
            </summary>
            <returns><see langword="true"/> if the string has no buffer or begins with a null terminator.
            Otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:LibHac.Common.U8StringMutable.IsNull">
            <summary>
            Checks if the <see cref="T:LibHac.Common.U8String"/> has no buffer.
            </summary>
            <returns><see langword="true"/> if the string has no buffer.
            Otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:LibHac.Common.U8StringMutable.IsEmpty">
            <summary>
            Checks if the <see cref="T:LibHac.Common.U8String"/> has no buffer or begins with a null terminator.
            </summary>
            <returns><see langword="true"/> if the string has no buffer or begins with a null terminator.
            Otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:LibHac.Crypto.Sha256.CreateSha256Generator">
            <summary>
            Creates an uninitialized SHA-256 <see cref="T:LibHac.Crypto.IHash"/> object.
            </summary>
            <returns> The new uninitialized SHA-256 <see cref="T:LibHac.Crypto.IHash"/> object.</returns>
        </member>
        <member name="T:LibHac.FsSrv.FileSystemProxyCore.MountNameInfo">
            <summary>
            Stores info obtained by parsing a common mount name.
            </summary>
        </member>
        <member name="P:LibHac.FsSrv.FileSystemServer.FsClient">
            <summary>The client instance to be used for internal operations like save indexer access.</summary>
        </member>
        <member name="M:LibHac.FsSrv.FileSystemServer.#ctor(LibHac.FsSrv.FileSystemServerConfig)">
            <summary>
            Creates a new <see cref="T:LibHac.FsSrv.FileSystemServer"/>.
            </summary>
            <param name="config">The configuration for the created <see cref="T:LibHac.FsSrv.FileSystemServer"/>.</param>
        </member>
        <member name="M:LibHac.FsSrv.FileSystemServer.CreateFileSystemClient">
            <summary>
            Creates a new <see cref="T:LibHac.Fs.FileSystemClient"/> using this <see cref="T:LibHac.FsSrv.FileSystemServer"/>'s
            <see cref="T:LibHac.ITimeSpanGenerator"/> for the client's access log.
            </summary>
            <returns>The created <see cref="T:LibHac.Fs.FileSystemClient"/>.</returns>
        </member>
        <member name="M:LibHac.FsSrv.FileSystemServer.CreateFileSystemClient(LibHac.ITimeSpanGenerator)">
            <summary>
            Creates a new <see cref="T:LibHac.Fs.FileSystemClient"/>.
            </summary>
            <param name="timer">The <see cref="T:LibHac.ITimeSpanGenerator"/> to use for the created
            <see cref="T:LibHac.Fs.FileSystemClient"/>'s access log.</param>
            <returns>The created <see cref="T:LibHac.Fs.FileSystemClient"/>.</returns>
        </member>
        <member name="T:LibHac.FsSrv.FileSystemServerConfig">
            <summary>
            Contains the configuration for creating a new <see cref="T:LibHac.FsSrv.FileSystemServer"/>.
            </summary>
        </member>
        <member name="P:LibHac.FsSrv.FileSystemServerConfig.FsCreators">
            <summary>
            The <see cref="T:LibHac.FsSrv.Creators.FileSystemCreators"/> used for creating filesystems.
            </summary>
        </member>
        <member name="P:LibHac.FsSrv.FileSystemServerConfig.DeviceOperator">
            <summary>
            An <see cref="T:LibHac.FsSrv.IDeviceOperator"/> for managing the gamecard and SD card.
            </summary>
        </member>
        <member name="P:LibHac.FsSrv.FileSystemServerConfig.ExternalKeySet">
            <summary>
            A keyset containing rights IDs and title keys.
            If null, an empty set will be created.
            </summary>
        </member>
        <member name="P:LibHac.FsSrv.FileSystemServerConfig.TimeSpanGenerator">
            <summary>
            Used for generating access log timestamps.
            If null, a new <see cref="T:LibHac.StopWatchTimeSpanGenerator"/> will be created.
            </summary>
        </member>
        <member name="T:LibHac.FsSrv.ISaveDataIndexer">
            <summary>
            Indexes save data metadata, holding key-value pairs of types <see cref="T:LibHac.Fs.SaveDataAttribute"/> and
            <see cref="T:LibHac.FsSrv.SaveDataIndexerValue"/> respectively. 
            </summary>
            <remarks>
            Each <see cref="T:LibHac.FsSrv.SaveDataIndexerValue"/> value contains information about the save data
            including its size and current state, as well as its <see cref="T:LibHac.Fs.SaveDataSpaceId"/> and save data
            ID which represent the save data's storage location on disk.
            </remarks>
        </member>
        <member name="M:LibHac.FsSrv.ISaveDataIndexer.Commit">
            <summary>
            Commit any changes made to the save data index.
            </summary>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.FsSrv.ISaveDataIndexer.Rollback">
            <summary>
            Rollback any changes made to the save data index since the last commit.
            </summary>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.FsSrv.ISaveDataIndexer.Reset">
            <summary>
            Remove all entries from the save data index and set the index to its initial state.
            </summary>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.FsSrv.ISaveDataIndexer.Publish(System.UInt64@,LibHac.Fs.SaveDataAttribute@)">
            <summary>
            Adds a new key to the index and returns the save data ID assigned to it.
            The created value will only contain the assigned save data ID.
            Fails if the key already exists.
            </summary>
            <param name="saveDataId">If the method returns successfully, contains the 
            save data ID assigned to the new entry.
            Save data IDs are assigned using a counter that is incremented for each added save.</param>
            <param name="key">The key to add.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.FsSrv.ISaveDataIndexer.Get(LibHac.FsSrv.SaveDataIndexerValue@,LibHac.Fs.SaveDataAttribute@)">
            <summary>
            Retrieves the <see cref="T:LibHac.FsSrv.SaveDataIndexerValue"/> for the specified <see cref="T:LibHac.Fs.SaveDataAttribute"/> key.
            </summary>
            <param name="value">If the method returns successfully, contains the 
            save data ID assigned to the new entry.</param>
            <param name="key">The key of the value to get.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.FsSrv.ISaveDataIndexer.PutStaticSaveDataIdIndex(LibHac.Fs.SaveDataAttribute@)">
            <summary>
            Adds a key with a pre-specified static save data ID to the index.
            </summary>
            <remarks>
            Adding a save data ID that is already in the index is not allowed. Adding a static ID that might
            conflict with a future dynamically-assigned ID should be avoided, otherwise there will be two saves
            with the same ID.
            FileSystemProxy avoids this by setting the high bit on static IDs. e.g. 0x8000000000000015
            </remarks>
            <param name="key">The key to add.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.FsSrv.ISaveDataIndexer.IsRemainedReservedOnly">
            <summary>
            Determines if there are any non-reserved entry slots remaining in the index.
            </summary>
            <remarks>If the <see cref="T:LibHac.FsSrv.ISaveDataIndexer"/> has a fixed number of entries, a portion of
            those entries may be reserved for internal use, </remarks>
            <returns><see langword="true"/> if there are any non-reserved entries remaining,
            otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:LibHac.FsSrv.ISaveDataIndexer.Delete(System.UInt64)">
            <summary>
            Removes the save data with the specified save data ID from the index.
            </summary>
            <param name="saveDataId">The ID of the save to be removed.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.FsSrv.ISaveDataIndexer.SetSpaceId(System.UInt64,LibHac.Fs.SaveDataSpaceId)">
            <summary>
            Sets the <see cref="T:LibHac.Fs.SaveDataSpaceId"/> in the specified save data's value.
            </summary>
            <param name="saveDataId">The save data ID of the save data to modify.</param>
            <param name="spaceId">The new <see cref="T:LibHac.Fs.SaveDataSpaceId"/> for the specified save data.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.FsSrv.ISaveDataIndexer.SetSize(System.UInt64,System.Int64)">
            <summary>
            Sets the size in the specified save data's value.
            </summary>
            <param name="saveDataId">The save data ID of the save data to modify.</param>
            <param name="size">The new size for the specified save data.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.FsSrv.ISaveDataIndexer.SetState(System.UInt64,LibHac.Fs.SaveDataState)">
            <summary>
            Sets the <see cref="T:LibHac.Fs.SaveDataState"/> in the specified save data's value.
            </summary>
            <param name="saveDataId">The save data ID of the save data to modify.</param>
            <param name="state">The new <see cref="T:LibHac.Fs.SaveDataState"/> for the specified save data.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.FsSrv.ISaveDataIndexer.GetKey(LibHac.Fs.SaveDataAttribute@,System.UInt64)">
            <summary>
            Gets the key of the specified save data ID.
            </summary>
            <param name="key">If the method returns successfully, contains the <see cref="T:LibHac.Fs.SaveDataAttribute"/>
            key of the specified save data ID.</param>
            <param name="saveDataId">The save data ID to locate.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.FsSrv.ISaveDataIndexer.GetValue(LibHac.FsSrv.SaveDataIndexerValue@,System.UInt64)">
            <summary>
            Gets the value of the specified save data ID.
            </summary>
            <param name="value">If the method returns successfully, contains the <see cref="T:LibHac.FsSrv.SaveDataIndexerValue"/>
            value of the specified save data ID.</param>
            <param name="saveDataId">The save data ID to locate.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.FsSrv.ISaveDataIndexer.SetValue(LibHac.Fs.SaveDataAttribute@,LibHac.FsSrv.SaveDataIndexerValue@)">
            <summary>
            Sets a new value to a key that already exists in the index.
            </summary>
            <param name="key">The key of the value to set.</param>
            <param name="value">The new value to associate with the specified key.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.FsSrv.ISaveDataIndexer.GetIndexCount">
            <summary>
            Gets the number of elements currently in the <see cref="T:LibHac.FsSrv.SaveDataIndexer"/>.
            </summary>
            <returns>The current element count.</returns>
        </member>
        <member name="M:LibHac.FsSrv.ISaveDataIndexer.OpenSaveDataInfoReader(LibHac.ReferenceCountedDisposable{LibHac.FsSrv.ISaveDataInfoReader}@)">
            <summary>
            Returns an <see cref="T:LibHac.FsSrv.ISaveDataInfoReader"/> that iterates through the <see cref="T:LibHac.FsSrv.SaveDataIndexer"/>.
            </summary>
            <param name="infoReader">If the method returns successfully, contains the created <see cref="T:LibHac.FsSrv.ISaveDataInfoReader"/>.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="T:LibHac.FsSrv.ISaveDataInfoReader">
            <summary>
            Iterates through the <see cref="T:LibHac.Fs.SaveDataInfo"/> of the save data
            in a single save data space.
            </summary>
        </member>
        <member name="M:LibHac.FsSrv.ISaveDataInfoReader.Read(System.Int64@,System.Span{System.Byte})">
            <summary>
            Returns the next <see cref="T:LibHac.Fs.SaveDataInfo"/> entries. This method will continue writing
            entries to <paramref name="saveDataInfoBuffer"/> until there is either no more space
            in the buffer, or until there are no more entries to iterate.
            </summary>
            <param name="readCount">If the method returns successfully, contains the number
            of <see cref="T:LibHac.Fs.SaveDataInfo"/> written to <paramref name="saveDataInfoBuffer"/>.
            A value of 0 indicates that there are no more entries to iterate, or the buffer is too small.</param>
            <param name="saveDataInfoBuffer">The buffer in which to write the <see cref="T:LibHac.Fs.SaveDataInfo"/>.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="T:LibHac.FsSrv.AccessPermissions">
            <summary>
            Permissions that control which filesystems or storages can be mounted or opened.
            </summary>
        </member>
        <member name="T:LibHac.FsSrv.ActionPermissions">
            <summary>
            Permissions that control which actions can be performed.
            </summary>
        </member>
        <member name="P:LibHac.FsSrv.ResultSdmmc.DeviceNotFound">
            <summary>Error code: 2024-0001; Inner value: 0x218</summary>
        </member>
        <member name="P:LibHac.FsSrv.ResultSdmmc.DeviceAsleep">
            <summary>Error code: 2024-0004; Inner value: 0x818</summary>
        </member>
        <member name="T:LibHac.FsSrv.SaveDataIndexer">
            <summary>
            Indexes metadata for persistent save data stored on disk, holding key-value pairs of types
            <see cref="T:LibHac.Fs.SaveDataAttribute"/> and <see cref="T:LibHac.FsSrv.SaveDataIndexerValue"/> respectively.
            </summary>
            <remarks>
            Each <see cref="T:LibHac.FsSrv.SaveDataIndexer"/> manages one to two save data spaces.
            Each save data space is identified by a <see cref="T:LibHac.Fs.SaveDataSpaceId"/>,
            and has its own unique storage location on disk.<br/>
            Based on FS 10.0.0 (nnSdk 10.4.0)
            </remarks>
        </member>
        <member name="M:LibHac.FsSrv.SaveDataIndexer.GenerateSaveDataInfo(LibHac.Fs.SaveDataInfo@,LibHac.Fs.SaveDataAttribute@,LibHac.FsSrv.SaveDataIndexerValue@)">
            <summary>
            Generates a <see cref="T:LibHac.Fs.SaveDataInfo"/> from the provided <see cref="T:LibHac.Fs.SaveDataAttribute"/> and <see cref="T:LibHac.FsSrv.SaveDataIndexerValue"/>.
            </summary>
            <param name="info">When this method returns, contains the generated <see cref="T:LibHac.Fs.SaveDataInfo"/>.</param>
            <param name="key">The key used to generate the <see cref="T:LibHac.Fs.SaveDataInfo"/>.</param>
            <param name="value">The value used to generate the <see cref="T:LibHac.Fs.SaveDataInfo"/>.</param>
        </member>
        <member name="M:LibHac.FsSrv.SaveDataIndexer.TryInitializeDatabase">
            <summary>
            Initializes <see cref="P:LibHac.FsSrv.SaveDataIndexer.KvDatabase"/> and ensures that the indexer's save data is created.
            Does nothing if this <see cref="T:LibHac.FsSrv.SaveDataIndexer"/> has already been initialized.
            </summary>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.FsSrv.SaveDataIndexer.TryLoadDatabase(System.Boolean)">
            <summary>
            Ensures that the database file exists and loads any existing entries.
            Does nothing if the database has already been loaded and <paramref name="forceLoad"/> is <see langword="true"/>.
            </summary>
            <param name="forceLoad">If <see langword="true"/>, forces the database to be reloaded,
            even it it was already loaded previously.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.FsSrv.SaveDataIndexer.RegisterReader(LibHac.ReferenceCountedDisposable{LibHac.FsSrv.SaveDataIndexer.Reader})">
            <summary>
            Adds a <see cref="T:LibHac.FsSrv.SaveDataIndexer.Reader"/> to the list of registered readers.
            </summary>
            <param name="reader">The reader to add.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.FsSrv.SaveDataIndexer.UnregisterReader">
            <summary>
            Removes any <see cref="T:LibHac.FsSrv.SaveDataIndexer.Reader"/>s that are no longer in use from the registered readers.
            </summary>
        </member>
        <member name="M:LibHac.FsSrv.SaveDataIndexer.FixReader(LibHac.Fs.SaveDataAttribute@)">
            <summary>
            Adjusts the position of any opened <see cref="T:LibHac.FsSrv.SaveDataIndexer.Reader"/>s so that they still point to the
            same element after the addition or removal of another element. If the reader was on the
            element that was removed, it will now point to the element that was next in the list.
            </summary>
            <param name="key">The key of the element that was removed or added.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="T:LibHac.FsSrv.SaveDataIndexer.Mounter">
            <summary>
            Mounts the storage for a <see cref="T:LibHac.FsSrv.SaveDataIndexer"/>, and unmounts the storage
            when the <see cref="T:LibHac.FsSrv.SaveDataIndexer.Mounter"/> is disposed;
            </summary>
        </member>
        <member name="T:LibHac.FsSrv.SaveDataIndexerLite">
            <summary>
            Indexes metadata for temporary save data, holding a key-value pair of types
            <see cref="T:LibHac.Fs.SaveDataAttribute"/> and <see cref="T:LibHac.FsSrv.SaveDataIndexerValue"/> respectively. 
            </summary>
            <remarks>
            Only one temporary save data may exist at a time. When a new
            save data is added to the index, the existing key-value pair is replaced.<br/>
            Based on FS 10.0.0 (nnSdk 10.4.0)
            </remarks>
        </member>
        <member name="T:LibHac.FsSrv.SaveDataIndexerManager">
            <summary>
            Initializes and holds <see cref="T:LibHac.FsSrv.ISaveDataIndexer"/>s for each save data space.
            Creates accessors for individual SaveDataIndexers.
            </summary>
            <remarks>Based on FS 10.0.0 (nnSdk 10.4.0)</remarks>
        </member>
        <member name="M:LibHac.FsSrv.SaveDataIndexerManager.OpenAccessor(LibHac.FsSrv.SaveDataIndexerAccessor@,System.Boolean@,LibHac.Fs.SaveDataSpaceId)">
            <summary>
            Opens a <see cref="T:LibHac.FsSrv.SaveDataIndexerAccessor"/> for the specified save data space.
            </summary>
            <remarks>
            The returned <see cref="T:LibHac.FsSrv.SaveDataIndexerAccessor"/> will have exclusive access to the requested indexer.
            The accessor must be disposed after use.
            </remarks>
            <param name="accessor">If the method returns successfully, contains the created accessor.</param>
            <param name="neededInit">If the method returns successfully, contains <see langword="true"/>
            if the indexer needed to be initialized.</param>
            <param name="spaceId">The <see cref="T:LibHac.Fs.SaveDataSpaceId"/> of the indexer to open.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="T:LibHac.FsSrv.SaveDataIndexerAccessor">
            <summary>
            Gives exclusive access to an <see cref="T:LibHac.FsSrv.ISaveDataIndexer"/>.
            Releases the lock to the <see cref="T:LibHac.FsSrv.ISaveDataIndexer"/> upon disposal.
            </summary>
            <remarks>Based on FS 10.0.0 (nnSdk 10.4.0)</remarks>
        </member>
        <member name="M:LibHac.FsSystem.Aes128CtrStorage.#ctor(LibHac.Fs.IStorage,System.Byte[],System.Int64,System.Byte[],System.Boolean)">
            <summary>
            Creates a new AES storage
            </summary>
            <param name="baseStorage">The input <see cref="T:LibHac.Fs.IStorage"/>.</param>
            <param name="key">The decryption key.</param>
            <param name="counterOffset">Offset to add to the counter.</param>
            <param name="counterHi">The value of the upper 64 bits of the counter. Can be null.</param>
            <param name="leaveOpen"><see langword="true"/> to leave the storage open after the <see cref="T:LibHac.FsSystem.Aes128CtrStorage"/> object is disposed; otherwise, <see langword="false"/>.</param>
        </member>
        <member name="M:LibHac.FsSystem.Aes128XtsTransform.TransformBlock(System.Byte[],System.Int32,System.Int32,System.UInt64)">
            <summary>
            Transforms a single block.
            </summary>
            <param name="buffer"> The input for which to compute the transform.</param>
            <param name="offset">The offset into the byte array from which to begin using data.</param>
            <param name="count">The number of bytes in the byte array to use as data.</param>
            <param name="sector">The sector number of the block</param>
            <returns>The number of bytes written.</returns>
        </member>
        <member name="M:LibHac.FsSystem.Aes128XtsTransform.FillArrayFromSector(System.Byte[],System.UInt64)">
            <summary>
            Fills a byte array from a sector number (little endian)
            </summary>
            <param name="value">The destination</param>
            <param name="sector">The sector number</param>
        </member>
        <member name="M:LibHac.FsSystem.Aes128XtsTransform.TweakCrypt(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Byte[])">
            <summary>
            Performs the Xts TweakCrypt operation
            </summary>
        </member>
        <member name="M:LibHac.FsSystem.Aes128XtsTransform.MultiplyByX(System.Byte[])">
            <summary>
            Multiply by x
            </summary>
            <param name="i">The value to multiply by x (LFSR shift)</param>
        </member>
        <member name="M:LibHac.FsSystem.AesXtsDirectory.GetAesXtsFileSize(LibHac.Common.U8Span)">
            <summary>
            Reads the size of a NAX0 file from its header. Returns 0 on error.
            </summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:LibHac.FsSystem.AesXtsFileSystem.CreateFile(LibHac.Common.U8Span,System.Int64,LibHac.Fs.Fsa.CreateFileOptions,System.Byte[])">
            <summary>
            Creates a new <see cref="T:LibHac.FsSystem.AesXtsFile"/> using the provided key.
            </summary>
            <param name="path">The full path of the file to create.</param>
            <param name="size">The initial size of the created file.</param>
            <param name="options">Flags to control how the file is created.
            Should usually be <see cref="F:LibHac.Fs.Fsa.CreateFileOptions.None"/></param>
            <param name="key">The 256-bit key containing a 128-bit data key followed by a 128-bit tweak key.</param>
        </member>
        <member name="M:LibHac.FsSystem.BucketTree.Builder.Initialize(LibHac.Fs.SubStorage,LibHac.Fs.SubStorage,LibHac.Fs.SubStorage,System.Int32,System.Int32,System.Int32)">
            <summary>
            Initializes the bucket tree builder.
            </summary>
            <param name="headerStorage">The <see cref="T:LibHac.Fs.SubStorage"/> the tree's header will be written to.Must be at least the size in bytes returned by <see cref="M:LibHac.FsSystem.BucketTree.QueryHeaderStorageSize"/>.</param>
            <param name="nodeStorage">The <see cref="T:LibHac.Fs.SubStorage"/> the tree's nodes will be written to. Must be at least the size in bytes returned by <see cref="M:LibHac.FsSystem.BucketTree.QueryNodeStorageSize(System.Int64,System.Int64,System.Int32)"/>.</param>
            <param name="entryStorage">The <see cref="T:LibHac.Fs.SubStorage"/> the tree's entries will be written to. Must be at least the size in bytes returned by <see cref="M:LibHac.FsSystem.BucketTree.QueryEntryStorageSize(System.Int64,System.Int64,System.Int32)"/>.</param>
            <param name="nodeSize">The size of each node in the bucket tree. Must be a power of 2.</param>
            <param name="entrySize">The size of each entry that will be stored in the bucket tree.</param>
            <param name="entryCount">The exact number of entries that will be added to the bucket tree.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.FsSystem.BucketTree.Builder.Add``1(``0@)">
            <summary>
            Adds a new entry to the bucket tree.
            </summary>
            <typeparam name="T">The type of the entry to add. Added entries should all be the same type.</typeparam>
            <param name="entry">The entry to add.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.FsSystem.BucketTree.Builder.FinalizePreviousEntrySet(System.Int64)">
            <summary>
            Checks if a new entry set is being started. If so, sets the end offset of the previous
            entry set and writes it to the output storage.
            </summary>
            <param name="endOffset">The end offset of the previous entry.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.FsSystem.BucketTree.Builder.AddEntryOffset(System.Int64)">
            <summary>
            If needed, adds a new entry set's start offset to the L1 or L2 nodes.
            </summary>
            <param name="entryOffset">The start offset of the entry being added.</param>
        </member>
        <member name="M:LibHac.FsSystem.BucketTree.Builder.Finalize(System.Int64)">
            <summary>
            Finalizes the bucket tree. Must be called after all entries are added.
            </summary>
            <param name="endOffset">The end offset of the bucket tree.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="T:LibHac.FsSystem.ConcatenationFileSystem">
             <summary>
             An <see cref="T:LibHac.Fs.Fsa.IFileSystem"/> that stores large files as smaller, separate sub-files.
             </summary>
             <remarks>
             This filesystem is mainly used to allow storing large files on filesystems that have low
             limits on file size such as FAT filesystems. The underlying base filesystem must have
             support for the "Archive" file attribute found in FAT or NTFS filesystems.
            
             A <see cref="T:LibHac.FsSystem.ConcatenationFileSystem"/> may contain both standard files or Concatenation files.
             If a directory has the archive attribute set, its contents will be concatenated and treated
             as a single file. These sub-files must follow the naming scheme "00", "01", "02", ...
             Each sub-file except the final one must have the size <see cref="P:LibHac.FsSystem.ConcatenationFileSystem.SubFileSize"/> that was specified
             at the creation of the <see cref="T:LibHac.FsSystem.ConcatenationFileSystem"/>.
             </remarks>
        </member>
        <member name="M:LibHac.FsSystem.ConcatenationFileSystem.#ctor(LibHac.Fs.Fsa.IAttributeFileSystem)">
            <summary>
            Initializes a new <see cref="T:LibHac.FsSystem.ConcatenationFileSystem"/>.
            </summary>
            <param name="baseFileSystem">The base <see cref="T:LibHac.Fs.Fsa.IAttributeFileSystem"/> for the
            new <see cref="T:LibHac.FsSystem.ConcatenationFileSystem"/>.</param>
        </member>
        <member name="M:LibHac.FsSystem.ConcatenationFileSystem.#ctor(LibHac.Fs.Fsa.IAttributeFileSystem,System.Int64)">
            <summary>
            Initializes a new <see cref="T:LibHac.FsSystem.ConcatenationFileSystem"/>.
            </summary>
            <param name="baseFileSystem">The base <see cref="T:LibHac.Fs.Fsa.IAttributeFileSystem"/> for the
            new <see cref="T:LibHac.FsSystem.ConcatenationFileSystem"/>.</param>
            <param name="subFileSize">The size of each sub-file. Once a file exceeds this size, a new sub-file will be created</param>
        </member>
        <member name="T:LibHac.FsSystem.DirectorySaveDataFileSystem">
            <summary>
            An <see cref="T:LibHac.Fs.Fsa.IFileSystem"/> that provides transactional commits for savedata on top of another base IFileSystem.
            </summary>
            <remarks>
            Transactional commits should be atomic as long as the <see cref="M:LibHac.Fs.Fsa.IFileSystem.RenameDirectory(LibHac.Common.U8Span,LibHac.Common.U8Span)"/> function of the
            underlying <see cref="T:LibHac.Fs.Fsa.IFileSystem"/> is atomic.<br/>
            Based on FS 10.0.0 (nnSdk 10.4.0)
            </remarks>
        </member>
        <member name="M:LibHac.FsSystem.DirectorySaveDataFileSystem.SynchronizeDirectory(LibHac.Common.U8Span,LibHac.Common.U8Span)">
            <summary>
            Creates the destination directory if needed and copies the source directory to it.
            </summary>
            <param name="destPath">The path of the destination directory.</param>
            <param name="sourcePath">The path of the source directory.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="P:LibHac.FsSystem.HierarchicalIntegrityVerificationStorage.LevelValidities">
            <summary>
            An array of the hash statuses of every block in each level.
            </summary>
        </member>
        <member name="M:LibHac.FsSystem.HierarchicalIntegrityVerificationStorage.Validate(System.Boolean,LibHac.IProgressReport)">
            <summary>
            Checks the hashes of any unchecked blocks and returns the <see cref="T:LibHac.Validity"/> of the data.
            </summary>
            <param name="returnOnError">If <see langword="true"/>, return as soon as an invalid block is found.</param>
            <param name="logger">An optional <see cref="T:LibHac.IProgressReport"/> for reporting progress.</param>
            <returns>The <see cref="T:LibHac.Validity"/> of the data of the specified hash level.</returns>
        </member>
        <member name="T:LibHac.FsSystem.IntegrityVerificationInfo">
            <summary>
            Information for creating an <see cref="T:LibHac.FsSystem.IntegrityVerificationStorage"/>
            </summary>
        </member>
        <member name="T:LibHac.FsSystem.IntegrityCheckLevel">
            <summary>
            Represents the level of integrity checks to be performed.
            </summary>
        </member>
        <member name="F:LibHac.FsSystem.IntegrityCheckLevel.None">
            <summary>
            No integrity checks will be performed.
            </summary>
        </member>
        <member name="F:LibHac.FsSystem.IntegrityCheckLevel.IgnoreOnInvalid">
            <summary>
            Invalid blocks will be marked as invalid when read, and will not cause an error.
            </summary>
        </member>
        <member name="F:LibHac.FsSystem.IntegrityCheckLevel.ErrorOnInvalid">
            <summary>
            An <see cref="T:System.IO.InvalidDataException"/> will be thrown if an integrity check fails.
            </summary>
        </member>
        <member name="P:LibHac.FsSystem.LayeredFileSystem.Sources">
            <summary>
            List of source <see cref="T:LibHac.Fs.Fsa.IFileSystem"/>s.
            Filesystems at the beginning of the list will take precedence over those later in the list.
            </summary>
        </member>
        <member name="M:LibHac.FsSystem.LayeredFileSystem.#ctor(LibHac.Fs.Fsa.IFileSystem,LibHac.Fs.Fsa.IFileSystem)">
            <summary>
            Creates a new <see cref="T:LibHac.FsSystem.LayeredFileSystem"/> from the input <see cref="T:LibHac.Fs.Fsa.IFileSystem"/> objects.
            </summary>
            <param name="lowerFileSystem">The base <see cref="T:LibHac.Fs.Fsa.IFileSystem"/>.</param>
            <param name="upperFileSystem">The <see cref="T:LibHac.Fs.Fsa.IFileSystem"/> to be layered on top of the <paramref name="lowerFileSystem"/>.</param>
        </member>
        <member name="M:LibHac.FsSystem.LayeredFileSystem.#ctor(System.Collections.Generic.IList{LibHac.Fs.Fsa.IFileSystem})">
            <summary>
            Creates a new <see cref="T:LibHac.FsSystem.LayeredFileSystem"/> from the input <see cref="T:LibHac.Fs.Fsa.IFileSystem"/> objects.
            </summary>
            <param name="sourceFileSystems">An <see cref="T:System.Collections.Generic.IList`1"/> containing the <see cref="T:LibHac.Fs.Fsa.IFileSystem"/>s
            used to create the <see cref="T:LibHac.FsSystem.LayeredFileSystem"/>. Filesystems at the beginning of the list will take
            precedence over those later in the list.</param>
        </member>
        <member name="M:LibHac.FsSystem.LocalFileSystem.#ctor(System.String)">
            <summary>
            Opens a directory on local storage as an <see cref="T:LibHac.Fs.Fsa.IFileSystem"/>.
            The directory will be created if it does not exist.
            </summary>
            <param name="basePath">The path that will be the root of the <see cref="T:LibHac.FsSystem.LocalFileSystem"/>.</param>
        </member>
        <member name="T:LibHac.FsSystem.NullStorage">
            <summary>
            An <see cref="T:LibHac.Fs.IStorage"/> that returns all zeros when read, and does nothing on write.
            </summary>
        </member>
        <member name="M:LibHac.FsSystem.PartitionFileSystemBuilder.#ctor(LibHac.Fs.Fsa.IFileSystem)">
            <summary>
            Creates a new <see cref="T:LibHac.FsSystem.PartitionFileSystemBuilder"/> and populates it with all
            the files in the root directory.
            </summary>
        </member>
        <member name="T:LibHac.FsSystem.PathParser">
            <summary>
            Enumerates a file or directory path one segment at a time.
            </summary>
            <remarks>When the parser is initialized <see cref="M:LibHac.FsSystem.PathParser.GetCurrent"/>
            will return the root directory name, i.e. an empty string.</remarks>
        </member>
        <member name="M:LibHac.FsSystem.PathParser.TryGetNext(System.ReadOnlySpan{System.Byte}@)">
            <summary>
            Moves the iterator to the next segment in the path and gets the name of that segment.
            </summary>
            <param name="name">When this method returns, contains the path segment's name.</param>
            <returns><see langword="true"/> if the <see cref="T:LibHac.FsSystem.PathParser"/> was able to
            move to the next path segment.
            <see langword="false"/> if there are no remaining path segments.</returns>
        </member>
        <member name="M:LibHac.FsSystem.PathParser.MoveNext">
            <summary>
            Moves the iterator to the next segment in the path.
            </summary>
            <returns><see langword="true"/> if the <see cref="T:LibHac.FsSystem.PathParser"/> was able to
            move to the next path segment.
            <see langword="false"/> if there are no remaining path segments.</returns>
        </member>
        <member name="M:LibHac.FsSystem.PathParser.GetCurrent">
            <summary>
            Gets the current path segment's name.
            </summary>
            <returns>The current path segment.</returns>
        </member>
        <member name="M:LibHac.FsSystem.PathParser.IsFinished">
            <summary>
            Checks if the current path segment is the final one.
            </summary>
            <returns><see langword="true"/> if the current path segment is the final one.</returns>
        </member>
        <member name="M:LibHac.FsSystem.PathTools.GetFileName(System.ReadOnlySpan{System.Byte})">
            <summary>
            Returns the name and extension parts of the given path. The returned ReadOnlySpan
            contains the characters of the path that follows the last separator in path.
            </summary>
        </member>
        <member name="M:LibHac.FsSystem.PathTools.IsSubPath(System.ReadOnlySpan{System.Char},System.ReadOnlySpan{System.Char})">
            <summary>
            Checks if either of the 2 paths is a sub-path of the other. Input paths must be normalized.
            </summary>
            <param name="path1">The first path to be compared.</param>
            <param name="path2">The second path to be compared.</param>
            <returns></returns>
        </member>
        <member name="M:LibHac.FsSystem.PathTools.IsSubPath(System.ReadOnlySpan{System.Byte},System.ReadOnlySpan{System.Byte})">
            <summary>
            Checks if either of the 2 paths is a sub-path of the other. Input paths must be normalized.
            </summary>
            <param name="path1">The first path to be compared.</param>
            <param name="path2">The second path to be compared.</param>
            <returns></returns>
        </member>
        <member name="T:LibHac.FsSystem.RomFs.HierarchicalRomFileTable`1">
             <summary>
             Represents the file table used by the RomFS format.
             </summary>
             <typeparam name="T">The type of the value to be stored for each file entry.</typeparam>
             <remarks>
             This file table stores the structure of the file tree in a RomFS.
             Each file or directory entry is stored in the table using its full path as a key.
             Once added, a file or directory is assigned an ID that can also be used to retrieve it.
             Each file entry contains a structure of type <typeparamref name="T"/>.
             In a standard RomFS, this includes the size of the file and its offset in the RomFS.
             Each directory entry contains the IDs for its first child file and first child directory.
            
             The table is represented by four byte arrays. Two of the arrays contain the hash buckets and
             entries for the files, and the other two for the directories.
             
             Once all files have been added to the table, <see cref="M:LibHac.FsSystem.RomFs.HierarchicalRomFileTable`1.TrimExcess"/> should be called
             to optimize the size of the table.
             </remarks>
        </member>
        <member name="M:LibHac.FsSystem.RomFs.HierarchicalRomFileTable`1.#ctor(LibHac.Fs.IStorage,LibHac.Fs.IStorage,LibHac.Fs.IStorage,LibHac.Fs.IStorage)">
            <summary>
            Initializes a <see cref="T:LibHac.FsSystem.RomFs.HierarchicalRomFileTable`1"/> from an existing table.
            </summary>
            <param name="dirHashTable"></param>
            <param name="dirEntryTable"></param>
            <param name="fileHashTable"></param>
            <param name="fileEntryTable"></param>
        </member>
        <member name="M:LibHac.FsSystem.RomFs.HierarchicalRomFileTable`1.#ctor">
            <summary>
            Initializes a new <see cref="T:LibHac.FsSystem.RomFs.HierarchicalRomFileTable`1"/> that has the default initial capacity.
            </summary>
        </member>
        <member name="M:LibHac.FsSystem.RomFs.HierarchicalRomFileTable`1.#ctor(System.Int32,System.Int32)">
            <summary>
            Initializes a new <see cref="T:LibHac.FsSystem.RomFs.HierarchicalRomFileTable`1"/> that has the specified initial capacity.
            </summary>
            <param name="directoryCapacity">The initial number of directories that the
            <see cref="T:LibHac.FsSystem.RomFs.HierarchicalRomFileTable`1"/> can contain.</param>
            <param name="fileCapacity">The initial number of files that the
            <see cref="T:LibHac.FsSystem.RomFs.HierarchicalRomFileTable`1"/> can contain.</param>
        </member>
        <member name="M:LibHac.FsSystem.RomFs.HierarchicalRomFileTable`1.TryOpenDirectory(System.String,LibHac.FsSystem.RomFs.FindPosition@)">
            <summary>
            Opens a directory for enumeration.
            </summary>
            <param name="path">The full path of the directory to open.</param>
            <param name="position">The initial position of the directory enumerator.</param>
            <returns><see langword="true"/> if the table contains a directory with the specified path;
            otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:LibHac.FsSystem.RomFs.HierarchicalRomFileTable`1.TryOpenDirectory(System.Int32,LibHac.FsSystem.RomFs.FindPosition@)">
            <summary>
            Opens a directory for enumeration.
            </summary>
            <param name="directoryId">The ID of the directory to open.</param>
            <param name="position">When this method returns, contains the initial position of the directory enumerator.</param>
            <returns><see langword="true"/> if the table contains a directory with the specified path;
            otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:LibHac.FsSystem.RomFs.HierarchicalRomFileTable`1.FindNextFile(LibHac.FsSystem.RomFs.FindPosition@,`0@,System.String@)">
            <summary>
            Returns the next file in a directory and updates the enumerator's position.
            </summary>
            <param name="position">The current position of the directory enumerator.
            This position will be updated when the method returns.</param>
            <param name="info">When this method returns, contains the file's metadata.</param>
            <param name="name">When this method returns, contains the file's name (Not the full path).</param>
            <returns><see langword="true"/> if the next file was successfully returned.
            <see langword="false"/> if there are no more files to enumerate.</returns>
        </member>
        <member name="M:LibHac.FsSystem.RomFs.HierarchicalRomFileTable`1.FindNextDirectory(LibHac.FsSystem.RomFs.FindPosition@,System.String@)">
            <summary>
            Returns the next child directory in a directory and updates the enumerator's position.
            </summary>
            <param name="position">The current position of the directory enumerator.
            This position will be updated when the method returns.</param>
            <param name="name">When this method returns, contains the directory's name (Not the full path).</param>
            <returns><see langword="true"/> if the next directory was successfully returned.
            <see langword="false"/> if there are no more directories to enumerate.</returns>
        </member>
        <member name="M:LibHac.FsSystem.RomFs.HierarchicalRomFileTable`1.AddFile(System.String,`0@)">
            <summary>
            Adds a file to the file table. If the file already exists
            its <see cref="T:LibHac.FsSystem.RomFs.RomFileInfo"/> will be updated.
            </summary>
            <param name="path">The full path of the file to be added.</param>
            <param name="fileInfo">The file information to be stored.</param>
        </member>
        <member name="M:LibHac.FsSystem.RomFs.HierarchicalRomFileTable`1.AddDirectory(System.String)">
            <summary>
            Adds a directory to the file table. If the directory already exists,
            no action is performed.
            </summary>
            <param name="path">The full path of the directory to be added.</param>
        </member>
        <member name="M:LibHac.FsSystem.RomFs.HierarchicalRomFileTable`1.TrimExcess">
            <summary>
            Sets the capacity of this dictionary to what it would be if
            it had been originally initialized with all its entries.
            
            This method can be used to minimize the memory overhead 
            once it is known that no new elements will be added.
            </summary>
        </member>
        <member name="T:LibHac.FsSystem.RomFs.RomFsBuilder">
            <summary>
            Builds a RomFS from a collection of files.
            </summary>
            <remarks>A <see cref="T:LibHac.FsSystem.RomFs.RomFsBuilder"/> produces a view of a RomFS archive.
            When doing so, it will create an <see cref="T:LibHac.Fs.IStorage"/> instance that will
            provide the RomFS data when read. Random seek is supported.</remarks>
        </member>
        <member name="M:LibHac.FsSystem.RomFs.RomFsBuilder.#ctor">
            <summary>
            Creates a new, empty <see cref="T:LibHac.FsSystem.RomFs.RomFsBuilder"/>
            </summary>
        </member>
        <member name="M:LibHac.FsSystem.RomFs.RomFsBuilder.#ctor(LibHac.Fs.Fsa.IFileSystem)">
            <summary>
            Creates a new <see cref="T:LibHac.FsSystem.RomFs.RomFsBuilder"/> and populates it with all
            the files in the specified <see cref="T:LibHac.Fs.Fsa.IFileSystem"/>.
            </summary>
        </member>
        <member name="M:LibHac.FsSystem.RomFs.RomFsBuilder.AddFile(System.String,LibHac.Fs.Fsa.IFile)">
            <summary>
            Adds a file to the RomFS.
            </summary>
            <param name="path">The full path in the RomFS</param>
            <param name="file">An <see cref="T:LibHac.Fs.Fsa.IFile"/> of the file data to add.</param>
        </member>
        <member name="M:LibHac.FsSystem.RomFs.RomFsBuilder.Build">
            <summary>
            Returns a view of a RomFS containing all the currently added files.
            Additional files may be added and a new view produced without
            invalidating previously built RomFS views.
            </summary>
            <returns></returns>
        </member>
        <member name="T:LibHac.FsSystem.RomFs.FindPosition">
            <summary>
            Represents the current position when enumerating a directory's contents.
            </summary>
        </member>
        <member name="F:LibHac.FsSystem.RomFs.FindPosition.NextDirectory">
            <summary>The ID of the next directory to be enumerated.</summary>
        </member>
        <member name="F:LibHac.FsSystem.RomFs.FindPosition.NextFile">
            <summary>The ID of the next file to be enumerated.</summary>
        </member>
        <member name="M:LibHac.FsSystem.Save.AllocationTable.Join(System.Int32,System.Int32)">
            <summary>
            Combines 2 lists into one list. The second list will be attached to the end of the first list.
            </summary>
            <param name="frontListBlockIndex">The index of the start block of the first list.</param>
            <param name="backListBlockIndex">The index of the start block of the second list.</param>
        </member>
        <member name="M:LibHac.FsSystem.Save.AllocationTable.Trim(System.Int32,System.Int32)">
            <summary>
            Trims an existing list to the specified length and returns the excess blocks as a new list.
            </summary>
            <param name="listHeadBlockIndex">The starting block of the list to trim.</param>
            <param name="newListLength">The length in blocks that the list will be shortened to.</param>
            <returns>The index of the head node of the removed blocks.</returns>
        </member>
        <member name="M:LibHac.FsSystem.Save.AllocationTable.Split(System.Int32,System.Int32)">
            <summary>
            Splits a single list segment into 2 segments. The sequence of blocks in the full list will remain the same.
            </summary>
            <param name="segmentBlockIndex">The block index of the segment to split.</param>
            <param name="firstSubSegmentLength">The length of the first subsegment.</param>
        </member>
        <member name="M:LibHac.FsSystem.Save.RemapStorage.#ctor(LibHac.Fs.IStorage,LibHac.Fs.IStorage,LibHac.Fs.IStorage,System.Boolean)">
            <summary>
            Creates a new <see cref="T:LibHac.FsSystem.Save.RemapStorage"/>
            </summary>
            <param name="storage">A <see cref="T:LibHac.Fs.IStorage"/> of the main data of the RemapStream.
            The <see cref="T:LibHac.FsSystem.Save.RemapStorage"/> object assumes complete ownership of the Storage.</param>
            <param name="header">The header for this RemapStorage.</param>
            <param name="mapEntries">The remapping entries for this RemapStorage.</param>
            <param name="leaveOpen"><see langword="true"/> to leave the storage open after the <see cref="T:LibHac.FsSystem.Save.RemapStorage"/> object is disposed; otherwise, <see langword="false"/>.</param>
        </member>
        <member name="T:LibHac.FsSystem.Save.SaveFindPosition">
            <summary>
            Represents the current position when enumerating a directory's contents.
            </summary>
        </member>
        <member name="F:LibHac.FsSystem.Save.SaveFindPosition.NextDirectory">
            <summary>The ID of the next directory to be enumerated.</summary>
        </member>
        <member name="F:LibHac.FsSystem.Save.SaveFindPosition.NextFile">
            <summary>The ID of the next file to be enumerated.</summary>
        </member>
        <member name="M:LibHac.FsSystem.Save.SaveFsList`1.TryGetValue(System.Int32,`0@,System.Span{System.Byte}@)">
            <summary>
            Gets the value and name associated with the specific index.
            </summary>
            <param name="index">The index of the value to get.</param>
            <param name="value">Contains the corresponding value if the method returns <see langword="true"/>.</param>
            <param name="name">The name of the given index will be written to this span if the method returns <see langword="true"/>.
            This span must be at least <see cref="P:LibHac.FsSystem.Save.SaveFsList`1.MaxNameLength"/> bytes long.</param>
            <returns><see langword="true"/> if the <see cref="T:LibHac.FsSystem.Save.SaveFsList`1"/> contains an element with
            the specified key; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:LibHac.FsSystem.Save.SaveFsList`1.GetValue(System.Int32,`0@,System.Span{System.Byte}@)">
            <summary>
            Gets the value and name associated with the specific index.
            </summary>
            <param name="index">The index of the value to get.</param>
            <param name="value">Contains the corresponding value when the method returns.</param>
            <param name="name">The name of the given index will be written to this span when the method returns.
            This span must be at least <see cref="P:LibHac.FsSystem.Save.SaveFsList`1.MaxNameLength"/> bytes long.</param>
        </member>
        <member name="M:LibHac.FsSystem.SectorStorage.ValidateSize(System.Int64,System.Int64)">
            <summary>
            Validates that the size is a multiple of the sector size
            </summary>
        </member>
        <member name="T:LibHac.FsSystem.StreamFile">
            <summary>
            Provides an <see cref="T:LibHac.Fs.Fsa.IFile"/> interface for interacting with a <see cref="T:System.IO.Stream"/>
            </summary>
        </member>
        <member name="T:LibHac.FsSystem.TruncatedSubStorage">
            <summary>
            A <see cref="T:LibHac.Fs.SubStorage"/> that truncates reads and writes that extend past the end of the base storage.
            </summary>
            <remarks>
            When reading and writing from a <see cref="T:LibHac.FsSystem.TruncatedSubStorage"/>, the size of the base
            storage will be checked. If needed, the size of the requested read/write will be truncated
            to stay within the bounds of the base storage.
            </remarks>
        </member>
        <member name="M:LibHac.FsSystem.ValueStringBuilder.GetPinnableReference">
            <summary>
            Get a pinnable reference to the builder.
            Does not ensure there is a null char after <see cref="P:LibHac.FsSystem.ValueStringBuilder.Length"/>
            This overload is pattern matched in the C# 7.3+ compiler so you can omit
            the explicit method call, and write eg "fixed (char* c = builder)"
            </summary>
        </member>
        <member name="M:LibHac.FsSystem.ValueStringBuilder.GetPinnableReference(System.Boolean)">
            <summary>
            Get a pinnable reference to the builder.
            </summary>
            <param name="terminate">Ensures that the builder has a null char after <see cref="P:LibHac.FsSystem.ValueStringBuilder.Length"/></param>
        </member>
        <member name="P:LibHac.FsSystem.ValueStringBuilder.RawChars">
            <summary>Returns the underlying storage of the builder.</summary>
        </member>
        <member name="M:LibHac.FsSystem.ValueStringBuilder.AsSpan(System.Boolean)">
            <summary>
            Returns a span around the contents of the builder.
            </summary>
            <param name="terminate">Ensures that the builder has a null char after <see cref="P:LibHac.FsSystem.ValueStringBuilder.Length"/></param>
        </member>
        <member name="T:LibHac.Fs.Fsa.IDirectory">
            <summary>
            Provides an interface for enumerating the child entries of a directory.
            </summary>
        </member>
        <member name="M:LibHac.Fs.Fsa.IDirectory.Read(System.Int64@,System.Span{LibHac.Fs.DirectoryEntry})">
            <summary>
            Retrieves the next entries that this directory contains. Does not search subdirectories.
            </summary>
            <param name="entriesRead">The number of <see cref="T:LibHac.Fs.DirectoryEntry"/>s that
            were read into <paramref name="entryBuffer"/>.</param>
            <param name="entryBuffer">The buffer the entries will be read into.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the requested operation.</returns>
            <remarks>With each call of <see cref="M:LibHac.Fs.Fsa.IDirectory.Read(System.Int64@,System.Span{LibHac.Fs.DirectoryEntry})"/>, the <see cref="T:LibHac.Fs.Fsa.IDirectory"/> object will
            continue to iterate through all the entries it contains.
            Each call will attempt to read as many entries as the buffer can contain.
            Once all the entries have been read, all subsequent calls to <see cref="M:LibHac.Fs.Fsa.IDirectory.Read(System.Int64@,System.Span{LibHac.Fs.DirectoryEntry})"/> will
            read 0 entries into the buffer.</remarks>
        </member>
        <member name="M:LibHac.Fs.Fsa.IDirectory.GetEntryCount(System.Int64@)">
            <summary>
            Retrieves the number of file system entries that this directory contains. Does not search subdirectories.
            </summary>
            <param name="entryCount">The number of child entries the directory contains.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the requested operation.</returns>
        </member>
        <member name="T:LibHac.Fs.Fsa.IFile">
             <summary>
             Provides an interface for reading and writing a sequence of bytes.
             </summary>
             <remarks><see cref="T:LibHac.Fs.Fsa.IFile"/> is similar to <see cref="T:LibHac.Fs.IStorage"/>, and has a few main differences:
             
             - <see cref="T:LibHac.Fs.Fsa.IFile"/> allows an <see cref="T:LibHac.Fs.OpenMode"/> to be set that controls read, write
             and append permissions for the file.
            
             - If the <see cref="T:LibHac.Fs.Fsa.IFile"/> cannot read or write as many bytes as requested, it will read
             or write as many bytes as it can and return that number of bytes to the caller.
            
             - If <see cref="M:LibHac.Fs.Fsa.IFile.Write(System.Int64,System.ReadOnlySpan{System.Byte},LibHac.Fs.WriteOption@)"/> is called on an offset past the end of the <see cref="T:LibHac.Fs.Fsa.IFile"/>,
             the <see cref="F:LibHac.Fs.OpenMode.AllowAppend"/> mode is set and the file supports expansion,
             the file will be expanded so that it is large enough to contain the written data.</remarks>
        </member>
        <member name="M:LibHac.Fs.Fsa.IFile.Read(System.Int64@,System.Int64,System.Span{System.Byte},LibHac.Fs.ReadOption@)">
            <summary>
            Reads a sequence of bytes from the current <see cref="T:LibHac.Fs.Fsa.IFile"/>.
            </summary>
            <param name="bytesRead">If the operation returns successfully, The total number of bytes read into
            the buffer. This can be less than the size of the buffer if the IFile is too short to fulfill the request.</param>
            <param name="offset">The offset in the <see cref="T:LibHac.Fs.Fsa.IFile"/> at which to begin reading.</param>
            <param name="destination">The buffer where the read bytes will be stored.
            The number of bytes read will be no larger than the length of the buffer.</param>
            <param name="option">Options for reading from the <see cref="T:LibHac.Fs.Fsa.IFile"/>.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the requested operation.</returns>
        </member>
        <member name="M:LibHac.Fs.Fsa.IFile.Read(System.Int64@,System.Int64,System.Span{System.Byte})">
            <summary>
            Reads a sequence of bytes from the current <see cref="T:LibHac.Fs.Fsa.IFile"/> with no <see cref="T:LibHac.Fs.ReadOption"/>s.
            </summary>
            <param name="bytesRead">If the operation returns successfully, The total number of bytes read into
            the buffer. This can be less than the size of the buffer if the IFile is too short to fulfill the request.</param>
            <param name="offset">The offset in the <see cref="T:LibHac.Fs.Fsa.IFile"/> at which to begin reading.</param>
            <param name="destination">The buffer where the read bytes will be stored.
            The number of bytes read will be no larger than the length of the buffer.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the requested operation.</returns>
        </member>
        <member name="M:LibHac.Fs.Fsa.IFile.Write(System.Int64,System.ReadOnlySpan{System.Byte},LibHac.Fs.WriteOption@)">
            <summary>
            Writes a sequence of bytes to the current <see cref="T:LibHac.Fs.Fsa.IFile"/>.
            </summary>
            <param name="offset">The offset in the <see cref="T:LibHac.Fs.IStorage"/> at which to begin writing.</param>
            <param name="source">The buffer containing the bytes to be written.</param>
            <param name="option">Options for writing to the <see cref="T:LibHac.Fs.Fsa.IFile"/>.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the requested operation.</returns>
        </member>
        <member name="M:LibHac.Fs.Fsa.IFile.Flush">
            <summary>
            Causes any buffered data to be written to the underlying device.
            </summary>
        </member>
        <member name="M:LibHac.Fs.Fsa.IFile.SetSize(System.Int64)">
            <summary>
            Sets the size of the file in bytes.
            </summary>
            <param name="size">The desired size of the file in bytes.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the requested operation.</returns>
        </member>
        <member name="M:LibHac.Fs.Fsa.IFile.GetSize(System.Int64@)">
            <summary>
            Gets the number of bytes in the file.
            </summary>
            <param name="size">If the operation returns successfully, the length of the file in bytes.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the requested operation.</returns>
        </member>
        <member name="M:LibHac.Fs.Fsa.IFile.OperateRange(System.Span{System.Byte},LibHac.Fs.OperationId,System.Int64,System.Int64,System.ReadOnlySpan{System.Byte})">
            <summary>
            Performs various operations on the file. Used to extend the functionality of the <see cref="T:LibHac.Fs.Fsa.IFile"/> interface.
            </summary>
            <param name="outBuffer">A buffer that will contain the response from the operation.</param>
            <param name="operationId">The operation to be performed.</param>
            <param name="offset">The offset of the range to operate on.</param>
            <param name="size">The size of the range to operate on.</param>
            <param name="inBuffer">An input buffer. Size may vary depending on the operation performed.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the requested operation.</returns>
        </member>
        <member name="M:LibHac.Fs.Fsa.IFile.OperateRange(LibHac.Fs.OperationId,System.Int64,System.Int64)">
            <summary>
            Performs various operations on the file. Used to extend the functionality of the <see cref="T:LibHac.Fs.Fsa.IFile"/> interface.
            </summary>
            <param name="operationId">The operation to be performed.</param>
            <param name="offset">The offset of the range to operate on.</param>
            <param name="size">The size of the range to operate on.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the requested operation.</returns>
        </member>
        <member name="T:LibHac.Fs.Fsa.IFileSystem">
            <summary>
            Provides an interface for accessing a file system. <c>/</c> is used as the path delimiter.
            </summary>
        </member>
        <member name="M:LibHac.Fs.Fsa.IFileSystem.CreateFile(LibHac.Common.U8Span,System.Int64,LibHac.Fs.Fsa.CreateFileOptions)">
            <summary>
            Creates or overwrites a file at the specified path.
            </summary>
            <param name="path">The full path of the file to create.</param>
            <param name="size">The initial size of the created file.</param>
            <param name="option">Flags to control how the file is created.
            Should usually be <see cref="F:LibHac.Fs.Fsa.CreateFileOptions.None"/></param>
            <returns>The <see cref="T:LibHac.Result"/> of the requested operation.</returns>
            <remarks>
            The following <see cref="T:LibHac.Result"/> codes may be returned under certain conditions:
            
            The parent directory of the specified path does not exist: <see cref="P:LibHac.Fs.ResultFs.PathNotFound"/>
            Specified path already exists as either a file or directory: <see cref="P:LibHac.Fs.ResultFs.PathAlreadyExists"/>
            Insufficient free space to create the file: <see cref="P:LibHac.Fs.ResultFs.InsufficientFreeSpace"/>
            </remarks>
        </member>
        <member name="M:LibHac.Fs.Fsa.IFileSystem.DeleteFile(LibHac.Common.U8Span)">
            <summary>
            Deletes the specified file.
            </summary>
            <param name="path">The full path of the file to delete.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the requested operation.</returns>
            <remarks>
            The following <see cref="T:LibHac.Result"/> codes may be returned under certain conditions:
            
            The specified path does not exist or is a directory: <see cref="P:LibHac.Fs.ResultFs.PathNotFound"/>
            </remarks>
        </member>
        <member name="M:LibHac.Fs.Fsa.IFileSystem.CreateDirectory(LibHac.Common.U8Span)">
            <summary>
            Creates all directories and subdirectories in the specified path unless they already exist.
            </summary>
            <param name="path">The full path of the directory to create.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the requested operation.</returns>
            <remarks>
            The following <see cref="T:LibHac.Result"/> codes may be returned under certain conditions:
            
            The parent directory of the specified path does not exist: <see cref="P:LibHac.Fs.ResultFs.PathNotFound"/>
            Specified path already exists as either a file or directory: <see cref="P:LibHac.Fs.ResultFs.PathAlreadyExists"/>
            Insufficient free space to create the directory: <see cref="P:LibHac.Fs.ResultFs.InsufficientFreeSpace"/>
            </remarks>
        </member>
        <member name="M:LibHac.Fs.Fsa.IFileSystem.DeleteDirectory(LibHac.Common.U8Span)">
            <summary>
            Deletes the specified directory.
            </summary>
            <param name="path">The full path of the directory to delete.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the requested operation.</returns>
            <remarks>
            The following <see cref="T:LibHac.Result"/> codes may be returned under certain conditions:
            
            The specified path does not exist or is a file: <see cref="P:LibHac.Fs.ResultFs.PathNotFound"/>
            The specified directory is not empty: <see cref="P:LibHac.Fs.ResultFs.DirectoryNotEmpty"/>
            </remarks>
        </member>
        <member name="M:LibHac.Fs.Fsa.IFileSystem.DeleteDirectoryRecursively(LibHac.Common.U8Span)">
            <summary>
            Deletes the specified directory and any subdirectories and files in the directory.
            </summary>
            <param name="path">The full path of the directory to delete.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the requested operation.</returns>
            <remarks>
            The following <see cref="T:LibHac.Result"/> codes may be returned under certain conditions:
            
            The specified path does not exist or is a file: <see cref="P:LibHac.Fs.ResultFs.PathNotFound"/>
            </remarks>
        </member>
        <member name="M:LibHac.Fs.Fsa.IFileSystem.CleanDirectoryRecursively(LibHac.Common.U8Span)">
            <summary>
            Deletes any subdirectories and files in the specified directory.
            </summary>
            <param name="path">The full path of the directory to clean.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the requested operation.</returns>
            <remarks>
            The following <see cref="T:LibHac.Result"/> codes may be returned under certain conditions:
            
            The specified path does not exist or is a file: <see cref="P:LibHac.Fs.ResultFs.PathNotFound"/>
            </remarks>
        </member>
        <member name="M:LibHac.Fs.Fsa.IFileSystem.RenameFile(LibHac.Common.U8Span,LibHac.Common.U8Span)">
            <summary>
            Renames or moves a file to a new location.
            </summary>
            <param name="oldPath">The full path of the file to rename.</param>
            <param name="newPath">The new full path of the file.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the requested operation.</returns>
            <remarks>
            If <paramref name="oldPath"/> and <paramref name="newPath"/> are the same, this function does nothing and returns successfully.
            The following <see cref="T:LibHac.Result"/> codes may be returned under certain conditions:
            
            <paramref name="oldPath"/> does not exist or is a directory: <see cref="P:LibHac.Fs.ResultFs.PathNotFound"/>
            <paramref name="newPath"/>'s parent directory does not exist: <see cref="P:LibHac.Fs.ResultFs.PathNotFound"/>
            <paramref name="newPath"/> already exists as either a file or directory: <see cref="P:LibHac.Fs.ResultFs.PathAlreadyExists"/>
            </remarks>
        </member>
        <member name="M:LibHac.Fs.Fsa.IFileSystem.RenameDirectory(LibHac.Common.U8Span,LibHac.Common.U8Span)">
            <summary>
            Renames or moves a directory to a new location.
            </summary>
            <param name="oldPath">The full path of the directory to rename.</param>
            <param name="newPath">The new full path of the directory.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the requested operation.</returns>
            <remarks>
            If <paramref name="oldPath"/> and <paramref name="newPath"/> are the same, this function does nothing and returns <see cref="P:LibHac.Result.Success"/>.
            The following <see cref="T:LibHac.Result"/> codes may be returned under certain conditions:
            
            <paramref name="oldPath"/> does not exist or is a file: <see cref="P:LibHac.Fs.ResultFs.PathNotFound"/>
            <paramref name="newPath"/>'s parent directory does not exist: <see cref="P:LibHac.Fs.ResultFs.PathNotFound"/>
            <paramref name="newPath"/> already exists as either a file or directory: <see cref="P:LibHac.Fs.ResultFs.PathAlreadyExists"/>
            Either <paramref name="oldPath"/> or <paramref name="newPath"/> is a subpath of the other: <see cref="P:LibHac.Fs.ResultFs.DestinationIsSubPathOfSource"/>
            </remarks>
        </member>
        <member name="M:LibHac.Fs.Fsa.IFileSystem.GetEntryType(LibHac.Fs.DirectoryEntryType@,LibHac.Common.U8Span)">
            <summary>
            Determines whether the specified path is a file or directory, or does not exist.
            </summary>
            <param name="entryType">If the operation returns successfully, the <see cref="T:LibHac.Fs.DirectoryEntryType"/> of the file.</param>
            <param name="path">The full path to check.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the requested operation.</returns>
        </member>
        <member name="M:LibHac.Fs.Fsa.IFileSystem.GetFreeSpaceSize(System.Int64@,LibHac.Common.U8Span)">
            <summary>
            Gets the amount of available free space on a drive, in bytes.
            </summary>
            <param name="freeSpace">If the operation returns successfully, the amount of free space available on the drive, in bytes.</param>
            <param name="path">The path of the drive to query. Unused in almost all cases.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the requested operation.</returns>
        </member>
        <member name="M:LibHac.Fs.Fsa.IFileSystem.GetTotalSpaceSize(System.Int64@,LibHac.Common.U8Span)">
            <summary>
            Gets the total size of storage space on a drive, in bytes.
            </summary>
            <param name="totalSpace">If the operation returns successfully, the total size of the drive, in bytes.</param>
            <param name="path">The path of the drive to query. Unused in almost all cases.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the requested operation.</returns>
        </member>
        <member name="M:LibHac.Fs.Fsa.IFileSystem.OpenFile(LibHac.Fs.Fsa.IFile@,LibHac.Common.U8Span,LibHac.Fs.OpenMode)">
            <summary>
            Opens an <see cref="T:LibHac.Fs.Fsa.IFile"/> instance for the specified path.
            </summary>
            <param name="file">If the operation returns successfully,
            An <see cref="T:LibHac.Fs.Fsa.IFile"/> instance for the specified path.</param>
            <param name="path">The full path of the file to open.</param>
            <param name="mode">Specifies the access permissions of the created <see cref="T:LibHac.Fs.Fsa.IFile"/>.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the requested operation.</returns>
            <remarks>
            The following <see cref="T:LibHac.Result"/> codes may be returned under certain conditions:
            
            The specified path does not exist or is a directory: <see cref="P:LibHac.Fs.ResultFs.PathNotFound"/>
            </remarks>
        </member>
        <member name="M:LibHac.Fs.Fsa.IFileSystem.OpenDirectory(LibHac.Fs.Fsa.IDirectory@,LibHac.Common.U8Span,LibHac.Fs.Fsa.OpenDirectoryMode)">
            <summary>
            Creates an <see cref="T:LibHac.Fs.Fsa.IDirectory"/> instance for enumerating the specified directory.
            </summary>
            <param name="directory">If the operation returns successfully,
            An <see cref="T:LibHac.Fs.Fsa.IDirectory"/> instance for the specified directory.</param>
            <param name="path">The directory's full path.</param>
            <param name="mode">Specifies which sub-entries should be enumerated.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the requested operation.</returns>
            <remarks>
            The following <see cref="T:LibHac.Result"/> codes may be returned under certain conditions:
            
            The specified path does not exist or is a file: <see cref="P:LibHac.Fs.ResultFs.PathNotFound"/>
            </remarks>
        </member>
        <member name="M:LibHac.Fs.Fsa.IFileSystem.Commit">
            <summary>
            Commits any changes to a transactional file system.
            Does nothing if called on a non-transactional file system.
            </summary>
            <returns>The <see cref="T:LibHac.Result"/> of the requested operation.</returns>
        </member>
        <member name="M:LibHac.Fs.Fsa.IFileSystem.GetFileTimeStampRaw(LibHac.Fs.FileTimeStampRaw@,LibHac.Common.U8Span)">
            <summary>
            Gets the creation, last accessed, and last modified timestamps of a file or directory.
            </summary>
            <param name="timeStamp">If the operation returns successfully, the timestamps for the specified file or directory.
            These value are expressed as Unix timestamps.</param>
            <param name="path">The path of the file or directory.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the requested operation.</returns>
            <remarks>
            The following <see cref="T:LibHac.Result"/> codes may be returned under certain conditions:
            
            The specified path does not exist: <see cref="P:LibHac.Fs.ResultFs.PathNotFound"/>
            </remarks>
        </member>
        <member name="M:LibHac.Fs.Fsa.IFileSystem.QueryEntry(System.Span{System.Byte},System.ReadOnlySpan{System.Byte},LibHac.Fs.Fsa.QueryId,LibHac.Common.U8Span)">
            <summary>
            Performs a query on the specified file.
            </summary>
            <remarks>This method allows implementers of <see cref="T:LibHac.Fs.Fsa.IFileSystem"/> to accept queries and operations
            not included in the IFileSystem interface itself.</remarks>
            <param name="outBuffer">The buffer for receiving data from the query operation.
            May be unused depending on the query type.</param>
            <param name="inBuffer">The buffer for sending data to the query operation.
            May be unused depending on the query type.</param>
            <param name="queryId">The type of query to perform.</param>
            <param name="path">The full path of the file to query.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the requested operation.</returns>
        </member>
        <member name="T:LibHac.Fs.Fsa.OpenDirectoryMode">
            <summary>
            Specifies which types of entries are returned when enumerating an <see cref="T:LibHac.Fs.Fsa.IDirectory"/>.
            </summary>
        </member>
        <member name="T:LibHac.Fs.Fsa.CreateFileOptions">
            <summary>
            Optional file creation flags.
            </summary>
        </member>
        <member name="F:LibHac.Fs.Fsa.CreateFileOptions.CreateConcatenationFile">
            <summary>
            On a <see cref="T:LibHac.FsSystem.ConcatenationFileSystem"/>, creates a concatenation file.
            </summary>
        </member>
        <member name="F:LibHac.Fs.Fsa.QueryId.MakeConcatFile">
            <summary>
            Turns a folder in a <see cref="T:LibHac.FsSystem.ConcatenationFileSystem"/> into a concatenation file by
            setting the directory's archive flag.
            </summary>
        </member>
        <member name="T:LibHac.Fs.OpenMode">
            <summary>
            Specifies which operations are available on an <see cref="T:LibHac.Fs.Fsa.IFile"/>.
            </summary>
        </member>
        <member name="T:LibHac.Fs.InMemoryFileSystem">
            <summary>
            A filesystem stored in-memory. Mainly used for testing.
            </summary>
        </member>
        <member name="T:LibHac.Fs.InMemoryFileSystem.MemoryStreamAccessor">
            <summary>
            Provides exclusive access to a <see cref="T:System.IO.MemoryStream"/> object.
            Used by <see cref="T:LibHac.Fs.InMemoryFileSystem.MemoryFile"/> to enable opening a file multiple times with differing permissions.
            </summary>
        </member>
        <member name="T:LibHac.Fs.IStorage">
            <summary>
            Provides an interface for reading and writing a sequence of bytes.
            </summary>
            <remarks>
            The official IStorage makes the <c>Read</c> etc. methods abstract and doesn't
            have <c>DoRead</c> etc. methods. We're using them here so we can make sure
            the object isn't disposed before calling the method implementation.
            </remarks>
        </member>
        <member name="M:LibHac.Fs.IStorage.Read(System.Int64,System.Span{System.Byte})">
            <summary>
            Reads a sequence of bytes from the current <see cref="T:LibHac.Fs.IStorage"/>.
            </summary>
            <param name="offset">The offset in the <see cref="T:LibHac.Fs.IStorage"/> at which to begin reading.</param>
            <param name="destination">The buffer where the read bytes will be stored.
            The number of bytes read will be equal to the length of the buffer.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.Fs.IStorage.Write(System.Int64,System.ReadOnlySpan{System.Byte})">
            <summary>
            Writes a sequence of bytes to the current <see cref="T:LibHac.Fs.IStorage"/>.
            </summary>
            <param name="offset">The offset in the <see cref="T:LibHac.Fs.IStorage"/> at which to begin writing.</param>
            <param name="source">The buffer containing the bytes to be written.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.Fs.IStorage.Flush">
            <summary>
            Causes any buffered data to be written to the underlying device.
            </summary>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.Fs.IStorage.SetSize(System.Int64)">
            <summary>
            Sets the size of the current <see cref="T:LibHac.Fs.IStorage"/>.
            </summary>
            <param name="size">The desired size of the <see cref="T:LibHac.Fs.IStorage"/> in bytes.</param>
        </member>
        <member name="M:LibHac.Fs.IStorage.GetSize(System.Int64@)">
            <summary>
            Gets the number of bytes in the <see cref="T:LibHac.Fs.IStorage"/>.
            </summary>
            <param name="size">If the operation returns successfully, the length of the file in bytes.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.Fs.IStorage.OperateRange(System.Span{System.Byte},LibHac.Fs.OperationId,System.Int64,System.Int64,System.ReadOnlySpan{System.Byte})">
            <summary>
            Performs various operations on the file. Used to extend the functionality of the <see cref="T:LibHac.Fs.IStorage"/> interface.
            </summary>
            <param name="outBuffer">A buffer that will contain the response from the operation.</param>
            <param name="operationId">The operation to be performed.</param>
            <param name="offset">The offset of the range to operate on.</param>
            <param name="size">The size of the range to operate on.</param>
            <param name="inBuffer">An input buffer. Size may vary depending on the operation performed.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.Fs.PathTool.ContainsParentDirectoryAlt(LibHac.Common.U8Span)">
            <summary>
            Checks if a path begins with / or \ and contains any of these patterns:
            "/..\", "\..\", "\../", "\..0" where '0' is the null terminator.
            </summary>
        </member>
        <member name="M:LibHac.Fs.PathUtility.ToSfPath(LibHac.Common.U8StringBuilder@)">
            <summary>
            Performs the extra functions that nn::fs::FspPathPrintf does on the string buffer.
            </summary>
            <param name="builder">The string builder to process.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="P:LibHac.Fs.ResultFs.HandledByAllProcess">
            <summary>Error code: 2002-0000; Range: 0-999; Inner value: 0x2</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.PathNotFound">
            <summary>Specified path does not exist<br/>Error code: 2002-0001; Inner value: 0x202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.PathAlreadyExists">
            <summary>Specified path already exists<br/>Error code: 2002-0002; Inner value: 0x402</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.TargetLocked">
            <summary>Resource already in use (file already opened, savedata filesystem already mounted)<br/>Error code: 2002-0007; Inner value: 0xe02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.DirectoryNotEmpty">
            <summary>Specified directory is not empty when trying to delete it<br/>Error code: 2002-0008; Inner value: 0x1002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.DirectoryStatusChanged">
            <summary>Error code: 2002-0013; Inner value: 0x1a02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InsufficientFreeSpace">
            <summary>Error code: 2002-0030; Range: 30-45; Inner value: 0x3c02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UsableSpaceNotEnoughForSaveData">
            <summary>Error code: 2002-0031; Inner value: 0x3e02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InsufficientFreeSpaceBis">
            <summary>Error code: 2002-0034; Range: 34-38; Inner value: 0x4402</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InsufficientFreeSpaceBisCalibration">
            <summary>Error code: 2002-0035; Inner value: 0x4602</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InsufficientFreeSpaceBisSafe">
            <summary>Error code: 2002-0036; Inner value: 0x4802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InsufficientFreeSpaceBisUser">
            <summary>Error code: 2002-0037; Inner value: 0x4a02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InsufficientFreeSpaceBisSystem">
            <summary>Error code: 2002-0038; Inner value: 0x4c02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InsufficientFreeSpaceSdCard">
            <summary>Error code: 2002-0039; Inner value: 0x4e02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedSdkVersion">
            <summary>Error code: 2002-0050; Inner value: 0x6402</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.MountNameAlreadyExists">
            <summary>Error code: 2002-0060; Inner value: 0x7802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.PartitionNotFound">
            <summary>Error code: 2002-1001; Inner value: 0x7d202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.TargetNotFound">
            <summary>Error code: 2002-1002; Inner value: 0x7d402</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.ExternalKeyNotFound">
            <summary>The requested external key was not found<br/>Error code: 2002-1004; Inner value: 0x7d802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.SdCardAccessFailed">
            <summary>Error code: 2002-2000; Range: 2000-2499; Inner value: 0xfa002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.SdCardNotFound">
            <summary>Error code: 2002-2001; Inner value: 0xfa202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.SdCardAsleep">
            <summary>Error code: 2002-2004; Inner value: 0xfa802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.GameCardAccessFailed">
            <summary>Error code: 2002-2500; Range: 2500-2999; Inner value: 0x138802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidBufferForGameCard">
            <summary>Error code: 2002-2503; Inner value: 0x138e02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.GameCardNotInserted">
            <summary>Error code: 2002-2520; Inner value: 0x13b002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.GameCardNotInsertedOnGetHandle">
            <summary>Error code: 2002-2951; Inner value: 0x170e02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidGameCardHandleOnRead">
            <summary>Error code: 2002-2952; Inner value: 0x171002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidGameCardHandleOnGetCardInfo">
            <summary>Error code: 2002-2954; Inner value: 0x171402</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidGameCardHandleOnOpenNormalPartition">
            <summary>Error code: 2002-2960; Inner value: 0x172002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidGameCardHandleOnOpenSecurePartition">
            <summary>Error code: 2002-2961; Inner value: 0x172202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.NotImplemented">
            <summary>Error code: 2002-3001; Inner value: 0x177202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedVersion">
            <summary>Error code: 2002-3002; Inner value: 0x177402</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.SaveDataPathAlreadyExists">
            <summary>Error code: 2002-3003; Inner value: 0x177602</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.OutOfRange">
            <summary>Error code: 2002-3005; Inner value: 0x177a02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.AllocationMemoryFailed">
            <summary>Error code: 2002-3200; Range: 3200-3499; Inner value: 0x190002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.AesXtsFileFileStorageAllocationError">
            <summary>Error code: 2002-3312; Inner value: 0x19e002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.AesXtsFileXtsStorageAllocationError">
            <summary>Error code: 2002-3313; Inner value: 0x19e202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.AesXtsFileAlignmentStorageAllocationError">
            <summary>Error code: 2002-3314; Inner value: 0x19e402</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.AesXtsFileStorageFileAllocationError">
            <summary>Error code: 2002-3315; Inner value: 0x19e602</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.AesXtsFileSubStorageAllocationError">
            <summary>Error code: 2002-3383; Inner value: 0x1a6e02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.MmcAccessFailed">
            <summary>Error code: 2002-3500; Range: 3500-3999; Inner value: 0x1b5802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.DataCorrupted">
            <summary>Error code: 2002-4000; Range: 4000-4999; Inner value: 0x1f4002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.RomCorrupted">
            <summary>Error code: 2002-4001; Range: 4001-4299; Inner value: 0x1f4202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.IndirectStorageCorrupted">
            <summary>Error code: 2002-4021; Range: 4021-4029; Inner value: 0x1f6a02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidIndirectEntryOffset">
            <summary>Error code: 2002-4022; Inner value: 0x1f6c02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidIndirectEntryStorageIndex">
            <summary>Error code: 2002-4023; Inner value: 0x1f6e02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidIndirectStorageSize">
            <summary>Error code: 2002-4024; Inner value: 0x1f7002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidIndirectVirtualOffset">
            <summary>Error code: 2002-4025; Inner value: 0x1f7202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidIndirectPhysicalOffset">
            <summary>Error code: 2002-4026; Inner value: 0x1f7402</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidIndirectStorageIndex">
            <summary>Error code: 2002-4027; Inner value: 0x1f7602</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.BucketTreeCorrupted">
            <summary>Error code: 2002-4031; Range: 4031-4039; Inner value: 0x1f7e02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidBucketTreeSignature">
            <summary>Error code: 2002-4032; Inner value: 0x1f8002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidBucketTreeEntryCount">
            <summary>Error code: 2002-4033; Inner value: 0x1f8202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidBucketTreeNodeEntryCount">
            <summary>Error code: 2002-4034; Inner value: 0x1f8402</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidBucketTreeNodeOffset">
            <summary>Error code: 2002-4035; Inner value: 0x1f8602</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidBucketTreeEntryOffset">
            <summary>Error code: 2002-4036; Inner value: 0x1f8802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidBucketTreeEntrySetOffset">
            <summary>Error code: 2002-4037; Inner value: 0x1f8a02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidBucketTreeNodeIndex">
            <summary>Error code: 2002-4038; Inner value: 0x1f8c02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidBucketTreeVirtualOffset">
            <summary>Error code: 2002-4039; Inner value: 0x1f8e02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.RomHostFileSystemCorrupted">
            <summary>Error code: 2002-4241; Range: 4241-4259; Inner value: 0x212202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.RomHostEntryCorrupted">
            <summary>Error code: 2002-4242; Inner value: 0x212402</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.RomHostFileDataCorrupted">
            <summary>Error code: 2002-4243; Inner value: 0x212602</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.RomHostFileCorrupted">
            <summary>Error code: 2002-4244; Inner value: 0x212802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidRomHostHandle">
            <summary>Error code: 2002-4245; Inner value: 0x212a02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.SaveDataCorrupted">
            <summary>Error code: 2002-4301; Range: 4301-4499; Inner value: 0x219a02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedSaveVersion">
            <summary>Error code: 2002-4302; Inner value: 0x219c02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidSaveDataEntryType">
            <summary>Error code: 2002-4303; Inner value: 0x219e02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidSaveDataHeader">
            <summary>Error code: 2002-4315; Inner value: 0x21b602</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidSaveDataIvfcMagic">
            <summary>Error code: 2002-4362; Inner value: 0x221402</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidSaveDataIvfcHashValidationBit">
            <summary>Error code: 2002-4363; Inner value: 0x221602</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidSaveDataIvfcHash">
            <summary>Error code: 2002-4364; Inner value: 0x221802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.EmptySaveDataIvfcHash">
            <summary>Error code: 2002-4372; Inner value: 0x222802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidSaveDataHashInIvfcTopLayer">
            <summary>Error code: 2002-4373; Inner value: 0x222a02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.SaveDataInvalidGptPartitionSignature">
            <summary>Error code: 2002-4402; Inner value: 0x226402</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.IncompleteBlockInZeroBitmapHashStorageFileSaveData">
            <summary>Error code: 2002-4427; Inner value: 0x229602</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.SaveDataHostFileSystemCorrupted">
            <summary>Error code: 2002-4441; Range: 4441-4459; Inner value: 0x22b202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.SaveDataHostEntryCorrupted">
            <summary>Error code: 2002-4442; Inner value: 0x22b402</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.SaveDataHostFileDataCorrupted">
            <summary>Error code: 2002-4443; Inner value: 0x22b602</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.SaveDataHostFileCorrupted">
            <summary>Error code: 2002-4444; Inner value: 0x22b802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidSaveDataHostHandle">
            <summary>Error code: 2002-4445; Inner value: 0x22ba02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.SaveDataAllocationTableCorrupted">
            <summary>Error code: 2002-4462; Inner value: 0x22dc02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.SaveDataFileTableCorrupted">
            <summary>Error code: 2002-4463; Inner value: 0x22de02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.AllocationTableIteratedRangeEntry">
            <summary>Error code: 2002-4464; Inner value: 0x22e002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.NcaCorrupted">
            <summary>Error code: 2002-4501; Range: 4501-4599; Inner value: 0x232a02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidNcaFsType">
            <summary>Error code: 2002-4512; Inner value: 0x234002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidNcaProgramId">
            <summary>Error code: 2002-4527; Inner value: 0x235e02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.IntegrityVerificationStorageCorrupted">
            <summary>Error code: 2002-4601; Range: 4601-4639; Inner value: 0x23f202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidIvfcMagic">
            <summary>Error code: 2002-4602; Inner value: 0x23f402</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidIvfcHashValidationBit">
            <summary>Error code: 2002-4603; Inner value: 0x23f602</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidIvfcHash">
            <summary>Error code: 2002-4604; Inner value: 0x23f802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.EmptyIvfcHash">
            <summary>Error code: 2002-4612; Inner value: 0x240802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidHashInIvfcTopLayer">
            <summary>Error code: 2002-4613; Inner value: 0x240a02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.PartitionFileSystemCorrupted">
            <summary>Error code: 2002-4641; Range: 4641-4659; Inner value: 0x244202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidPartitionFileSystemHashOffset">
            <summary>Error code: 2002-4642; Inner value: 0x244402</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidPartitionFileSystemHash">
            <summary>Error code: 2002-4643; Inner value: 0x244602</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidPartitionFileSystemMagic">
            <summary>Error code: 2002-4644; Inner value: 0x244802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidHashedPartitionFileSystemMagic">
            <summary>Error code: 2002-4645; Inner value: 0x244a02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidPartitionFileSystemEntryNameOffset">
            <summary>Error code: 2002-4646; Inner value: 0x244c02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.BuiltInStorageCorrupted">
            <summary>Error code: 2002-4661; Range: 4661-4679; Inner value: 0x246a02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidGptPartitionSignature">
            <summary>Error code: 2002-4662; Inner value: 0x246c02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.FatFileSystemCorrupted">
            <summary>Error code: 2002-4681; Range: 4681-4699; Inner value: 0x249202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.HostFileSystemCorrupted">
            <summary>Error code: 2002-4701; Range: 4701-4719; Inner value: 0x24ba02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.HostEntryCorrupted">
            <summary>Error code: 2002-4702; Inner value: 0x24bc02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.HostFileDataCorrupted">
            <summary>Error code: 2002-4703; Inner value: 0x24be02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.HostFileCorrupted">
            <summary>Error code: 2002-4704; Inner value: 0x24c002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidHostHandle">
            <summary>Error code: 2002-4705; Inner value: 0x24c202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.DatabaseCorrupted">
            <summary>Error code: 2002-4721; Range: 4721-4739; Inner value: 0x24e202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.SaveDataAllocationTableCorruptedInternal">
            <summary>Error code: 2002-4722; Inner value: 0x24e402</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.SaveDataFileTableCorruptedInternal">
            <summary>Error code: 2002-4723; Inner value: 0x24e602</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.AllocationTableIteratedRangeEntryInternal">
            <summary>Error code: 2002-4724; Inner value: 0x24e802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidAllocationTableOffset">
            <summary>Error code: 2002-4725; Inner value: 0x24ea02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.AesXtsFileSystemCorrupted">
            <summary>Error code: 2002-4741; Range: 4741-4759; Inner value: 0x250a02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.AesXtsFileHeaderTooShort">
            <summary>Error code: 2002-4742; Inner value: 0x250c02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.AesXtsFileHeaderInvalidKeys">
            <summary>Error code: 2002-4743; Inner value: 0x250e02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.AesXtsFileHeaderInvalidMagic">
            <summary>Error code: 2002-4744; Inner value: 0x251002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.AesXtsFileTooShort">
            <summary>Error code: 2002-4745; Inner value: 0x251202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.AesXtsFileHeaderTooShortInSetSize">
            <summary>Error code: 2002-4746; Inner value: 0x251402</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.AesXtsFileHeaderInvalidKeysInRenameFile">
            <summary>Error code: 2002-4747; Inner value: 0x251602</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.AesXtsFileHeaderInvalidKeysInSetSize">
            <summary>Error code: 2002-4748; Inner value: 0x251802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.SaveDataTransferDataCorrupted">
            <summary>Error code: 2002-4761; Range: 4761-4769; Inner value: 0x253202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.SignedSystemPartitionDataCorrupted">
            <summary>Error code: 2002-4771; Range: 4771-4779; Inner value: 0x254602</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.GameCardLogoDataCorrupted">
            <summary>Error code: 2002-4781; Inner value: 0x255a02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.MultiCommitContextCorrupted">
            <summary>Error code: 2002-4790; Range: 4790-4799; Inner value: 0x256c02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidMultiCommitContextVersion">
            <summary>The version of the multi-commit context file is too high for the current MultiCommitManager implementation.<br/>Error code: 2002-4791; Inner value: 0x256e02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidMultiCommitContextState">
            <summary>The multi-commit has not been provisionally committed.<br/>Error code: 2002-4792; Inner value: 0x257002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.ZeroBitmapFileCorrupted">
            <summary>Error code: 2002-4811; Range: 4811-4819; Inner value: 0x259602</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.IncompleteBlockInZeroBitmapHashStorageFile">
            <summary>Error code: 2002-4812; Inner value: 0x259802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.Unexpected">
            <summary>Error code: 2002-5000; Range: 5000-5999; Inner value: 0x271002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnexpectedErrorInHostFileFlush">
            <summary>Error code: 2002-5307; Inner value: 0x297602</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnexpectedErrorInHostFileGetSize">
            <summary>Error code: 2002-5308; Inner value: 0x297802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnknownHostFileSystemError">
            <summary>Error code: 2002-5309; Inner value: 0x297a02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidNcaMountPoint">
            <summary>Error code: 2002-5320; Inner value: 0x299002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.PreconditionViolation">
            <summary>Error code: 2002-6000; Range: 6000-6499; Inner value: 0x2ee002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidArgument">
            <summary>Error code: 2002-6001; Range: 6001-6199; Inner value: 0x2ee202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidPath">
            <summary>Error code: 2002-6002; Range: 6002-6029; Inner value: 0x2ee402</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.TooLongPath">
            <summary>Error code: 2002-6003; Inner value: 0x2ee602</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidCharacter">
            <summary>Error code: 2002-6004; Inner value: 0x2ee802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidPathFormat">
            <summary>Error code: 2002-6005; Inner value: 0x2eea02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.DirectoryUnobtainable">
            <summary>Error code: 2002-6006; Inner value: 0x2eec02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.NotNormalized">
            <summary>Error code: 2002-6007; Inner value: 0x2eee02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidPathForOperation">
            <summary>Error code: 2002-6030; Range: 6030-6059; Inner value: 0x2f1c02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.DirectoryNotDeletable">
            <summary>Error code: 2002-6031; Inner value: 0x2f1e02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.DestinationIsSubPathOfSource">
            <summary>Error code: 2002-6032; Inner value: 0x2f2002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.PathNotFoundInSaveDataFileTable">
            <summary>Error code: 2002-6033; Inner value: 0x2f2202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.DifferentDestFileSystem">
            <summary>Error code: 2002-6034; Inner value: 0x2f2402</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidOffset">
            <summary>Error code: 2002-6061; Inner value: 0x2f5a02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidSize">
            <summary>Error code: 2002-6062; Inner value: 0x2f5c02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.NullptrArgument">
            <summary>Error code: 2002-6063; Inner value: 0x2f5e02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidAlignment">
            <summary>Error code: 2002-6064; Inner value: 0x2f6002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidMountName">
            <summary>Error code: 2002-6065; Inner value: 0x2f6202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.ExtensionSizeTooLarge">
            <summary>Error code: 2002-6066; Inner value: 0x2f6402</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.ExtensionSizeInvalid">
            <summary>Error code: 2002-6067; Inner value: 0x2f6602</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidSaveDataInfoReader">
            <summary>Error code: 2002-6068; Inner value: 0x2f6802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidCacheStorageSize">
            <summary>Error code: 2002-6069; Inner value: 0x2f6a02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidCacheStorageIndex">
            <summary>Error code: 2002-6070; Inner value: 0x2f6c02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidCommitNameCount">
            <summary>Up to 10 file systems can be committed at the same time.<br/>Error code: 2002-6071; Inner value: 0x2f6e02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidOpenMode">
            <summary>Error code: 2002-6072; Inner value: 0x2f7002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidDirectoryOpenMode">
            <summary>Error code: 2002-6074; Inner value: 0x2f7402</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidEnumValue">
            <summary>Error code: 2002-6080; Range: 6080-6099; Inner value: 0x2f8002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidSaveDataState">
            <summary>Error code: 2002-6081; Inner value: 0x2f8202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidSaveDataSpaceId">
            <summary>Error code: 2002-6082; Inner value: 0x2f8402</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidOperationForOpenMode">
            <summary>Error code: 2002-6200; Range: 6200-6299; Inner value: 0x307002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.FileExtensionWithoutOpenModeAllowAppend">
            <summary>Error code: 2002-6201; Inner value: 0x307202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidOpenModeForRead">
            <summary>Error code: 2002-6202; Inner value: 0x307402</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.InvalidOpenModeForWrite">
            <summary>Error code: 2002-6203; Inner value: 0x307602</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedOperation">
            <summary>Error code: 2002-6300; Range: 6300-6399; Inner value: 0x313802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedOperationInSubStorageSetSize">
            <summary>Attempted to resize a non-resizable SubStorage.<br/>Error code: 2002-6302; Inner value: 0x313c02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedOperationInResizableSubStorageSetSize">
            <summary>Attempted to resize a SubStorage that wasn't located at the end of the base storage.<br/>Error code: 2002-6303; Inner value: 0x313e02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedOperationInMemoryStorageSetSize">
            <summary>Error code: 2002-6304; Inner value: 0x314002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedOperationInFileStorageOperateRange">
            <summary>Error code: 2002-6306; Inner value: 0x314402</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedOperationInAesCtrExStorageWrite">
            <summary>Error code: 2002-6310; Inner value: 0x314c02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedOperationInHierarchicalIvfcStorageSetSize">
            <summary>Error code: 2002-6316; Inner value: 0x315802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedOperationInIndirectStorageWrite">
            <summary>Error code: 2002-6324; Inner value: 0x316802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedOperationInIndirectStorageSetSize">
            <summary>Error code: 2002-6325; Inner value: 0x316a02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedOperationInRoGameCardStorageWrite">
            <summary>Error code: 2002-6350; Inner value: 0x319c02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedOperationInRoGameCardStorageSetSize">
            <summary>Error code: 2002-6351; Inner value: 0x319e02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedOperationInConcatFsQueryEntry">
            <summary>Error code: 2002-6359; Inner value: 0x31ae02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedOperationModifyRomFsFileSystem">
            <summary>Error code: 2002-6364; Inner value: 0x31b802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedOperationInRomFsFileSystem">
            <summary>Called RomFsFileSystem::CommitProvisionally.<br/>Error code: 2002-6365; Inner value: 0x31ba02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedOperationRomFsFileSystemGetSpace">
            <summary>Error code: 2002-6366; Inner value: 0x31bc02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedOperationModifyRomFsFile">
            <summary>Error code: 2002-6367; Inner value: 0x31be02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedOperationModifyReadOnlyFileSystem">
            <summary>Error code: 2002-6369; Inner value: 0x31c202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedOperationReadOnlyFileSystemGetSpace">
            <summary>Error code: 2002-6371; Inner value: 0x31c602</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedOperationModifyReadOnlyFile">
            <summary>Error code: 2002-6372; Inner value: 0x31c802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedOperationInReadOnlyFile">
            <summary>Error code: 2002-6373; Inner value: 0x31ca02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedOperationModifyPartitionFileSystem">
            <summary>Error code: 2002-6374; Inner value: 0x31cc02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedOperationInPartitionFileSystem">
            <summary>Called PartitionFileSystemCore::CommitProvisionally.<br/>Error code: 2002-6375; Inner value: 0x31ce02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedOperationInPartitionFileSetSize">
            <summary>Error code: 2002-6376; Inner value: 0x31d002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedOperationIdInPartitionFileSystem">
            <summary>Error code: 2002-6377; Inner value: 0x31d202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UnsupportedOperationInDirectorySaveDataFileSystem">
            <summary>Called DirectorySaveDataFileSystem::CommitProvisionally on a non-user savedata.<br/>Error code: 2002-6384; Inner value: 0x31e002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.PermissionDenied">
            <summary>Error code: 2002-6400; Range: 6400-6449; Inner value: 0x320002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.ExternalKeyAlreadyRegistered">
            <summary>Error code: 2002-6452; Inner value: 0x326802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.WriteStateUnflushed">
            <summary>Error code: 2002-6454; Inner value: 0x326c02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.WriteModeFileNotClosed">
            <summary>Error code: 2002-6457; Inner value: 0x327202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.AllocatorAlignmentViolation">
            <summary>Error code: 2002-6461; Inner value: 0x327a02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.MultiCommitFileSystemAlreadyAdded">
            <summary>The provided file system has already been added to the multi-commit manager.<br/>Error code: 2002-6463; Inner value: 0x327e02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.UserNotExist">
            <summary>Error code: 2002-6465; Inner value: 0x328202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.EntryNotFound">
            <summary>Error code: 2002-6600; Range: 6600-6699; Inner value: 0x339002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.TargetProgramIndexNotFound">
            <summary>Specified program index is not found<br/>Error code: 2002-6606; Inner value: 0x339c02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.OutOfResource">
            <summary>Error code: 2002-6700; Range: 6700-6799; Inner value: 0x345802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.BufferAllocationFailed">
            <summary>Error code: 2002-6705; Inner value: 0x346202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.MappingTableFull">
            <summary>Error code: 2002-6706; Inner value: 0x346402</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.AllocationTableInsufficientFreeBlocks">
            <summary>Error code: 2002-6707; Inner value: 0x346602</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.OpenCountLimit">
            <summary>Error code: 2002-6709; Inner value: 0x346a02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.MultiCommitFileSystemLimit">
            <summary>The maximum number of file systems have been added to the multi-commit manager.<br/>Error code: 2002-6710; Inner value: 0x346c02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.MappingFailed">
            <summary>Error code: 2002-6800; Range: 6800-6899; Inner value: 0x352002</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.RemapStorageMapFull">
            <summary>Error code: 2002-6811; Inner value: 0x353602</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.BadState">
            <summary>Error code: 2002-6900; Range: 6900-6999; Inner value: 0x35e802</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.NotInitialized">
            <summary>Error code: 2002-6902; Inner value: 0x35ec02</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.NotMounted">
            <summary>Error code: 2002-6905; Inner value: 0x35f202</summary>
        </member>
        <member name="P:LibHac.Fs.ResultFs.SaveDataIsExtending">
            <summary>Error code: 2002-6906; Inner value: 0x35f402</summary>
        </member>
        <member name="T:LibHac.Fs.SdCardAccessLog">
            <summary>
            The default access logger that will output to the SD card via <see cref="T:LibHac.FsSrv.FileSystemProxy"/>.
            </summary>
        </member>
        <member name="T:LibHac.Fs.Shim.Host">
            <summary>
            Contains functions for mounting file systems from a host computer.
            </summary>
            <remarks>
            All functions in this file are based on SDK 9.3
            </remarks>
        </member>
        <member name="M:LibHac.Fs.Shim.Host.MountHostRoot(LibHac.Fs.FileSystemClient)">
            <summary>
            Mounts the C:\ drive of a host Windows computer at @Host:/
            </summary>
            <param name="fs">The <see cref="T:LibHac.Fs.FileSystemClient"/> to use.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.Fs.Shim.Host.MountHostRoot(LibHac.Fs.FileSystemClient,LibHac.Fs.MountHostOption)">
            <summary>
            Mounts the C:\ drive of a host Windows computer at @Host:/
            </summary>
            <param name="fs">The <see cref="T:LibHac.Fs.FileSystemClient"/> to use.</param>
            <param name="option">Options for mounting the host file system.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.Fs.Shim.Host.UnmountHostRoot(LibHac.Fs.FileSystemClient)">
            <summary>
            Unmounts the file system at @Host:/
            </summary>
            <param name="fs">The <see cref="T:LibHac.Fs.FileSystemClient"/> to use.</param>
        </member>
        <member name="M:LibHac.Fs.Shim.Host.MountHost(LibHac.Fs.FileSystemClient,LibHac.Common.U8Span,LibHac.Common.U8Span)">
            <summary>
            Mounts a directory on a host Windows computer at the specified mount point.
            </summary>
            <param name="fs">The <see cref="T:LibHac.Fs.FileSystemClient"/> to use.</param>
            <param name="mountName">The mount name at which the file system will be mounted.</param>
            <param name="path">The path on the host computer to mount. e.g. C:\Windows\System32</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.Fs.Shim.Host.MountHost(LibHac.Fs.FileSystemClient,LibHac.Common.U8Span,LibHac.Common.U8Span,LibHac.Fs.MountHostOption)">
            <summary>
            Mounts a directory on a host Windows computer at the specified mount point.
            </summary>
            <param name="fs">The <see cref="T:LibHac.Fs.FileSystemClient"/> to use.</param>
            <param name="mountName">The mount name at which the file system will be mounted.</param>
            <param name="path">The path on the host computer to mount. e.g. C:\Windows\System32</param>
            <param name="option">Options for mounting the host file system.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.Fs.Shim.Host.MountHostImpl(LibHac.Fs.FileSystemClient,LibHac.Common.U8Span,LibHac.Common.U8Span,System.Nullable{LibHac.Fs.MountHostOption},System.String)">
            <summary>
            Mounts a directory on a host Windows computer at the specified mount point.
            </summary>
            <param name="fs">The <see cref="T:LibHac.Fs.FileSystemClient"/> to use.</param>
            <param name="mountName">The mount name at which the file system will be mounted.</param>
            <param name="path">The path on the host computer to mount. e.g. C:\Windows\System32</param>
            <param name="optionalOption">Options for mounting the host file system. Specifying this parameter is optional.</param>
            <param name="caller">The caller of this function.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.Fs.Shim.Host.PreMountHost(LibHac.Fs.ICommonMountNameGenerator@,LibHac.Common.U8Span,LibHac.Common.U8Span)">
            <summary>
            Creates an <see cref="T:LibHac.Fs.ICommonMountNameGenerator"/> based on the <paramref name="mountName"/> and
            <paramref name="path"/>, and verifies the <paramref name="mountName"/>.
            </summary>
            <param name="nameGenerator">If successful, the created <see cref="T:LibHac.Fs.ICommonMountNameGenerator"/>.</param>
            <param name="mountName">The mount name at which the file system will be mounted.</param>
            <param name="path">The path that will be opened on the host computer. e.g. C:\Windows\System32</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.Fs.Shim.Host.OpenHostFileSystem(LibHac.Fs.FileSystemClient,LibHac.Fs.Fsa.IFileSystem@,LibHac.Common.U8Span,LibHac.Common.U8Span,LibHac.Fs.MountHostOption)">
            <summary>
            Verifies parameters and opens a host file system.
            </summary>
            <param name="fs">The <see cref="T:LibHac.Fs.FileSystemClient"/> to use.</param>
            <param name="fileSystem">If successful, the opened host file system.</param>
            <param name="mountName">The mount name to be verified.</param>
            <param name="path">The path on the host computer to open. e.g. C:\Windows\System32</param>
            <param name="option">Options for opening the host file system.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.Fs.Shim.Host.OpenHostFileSystemImpl(LibHac.Fs.FileSystemClient,LibHac.Fs.Fsa.IFileSystem@,LibHac.FsSystem.FsPath@,LibHac.Fs.MountHostOption)">
            <summary>
            Opens a host file system via <see cref="T:LibHac.FsSrv.IFileSystemProxy"/>.
            </summary>
            <param name="fs">The <see cref="T:LibHac.Fs.FileSystemClient"/> to use.</param>
            <param name="fileSystem">If successful, the opened host file system.</param>
            <param name="path">The path on the host computer to open. e.g. /C:\Windows\System32/</param>
            <param name="option">Options for opening the host file system.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="T:LibHac.Fs.SubStorage">
             <summary>
             Presents a subsection of a base IStorage as a new IStorage.
             </summary>
             <remarks>
             A SubStorage presents a sub-range of an IStorage as a separate IStorage.
            
             The SubStorage doesn't check if the offset and size provided are actually in the base storage.
             GetSize will return the size given to the SubStorage at initialization and will not query
             the base storage's size.
            
             A SubStorage is non-resizable by default. <see cref="M:LibHac.Fs.SubStorage.SetResizable(System.Boolean)"/> may be used to mark
             the SubStorage as resizable. The SubStorage may only be resized if the end of the SubStorage
             is located at the end of the base storage. When resizing the SubStorage, the base storage
             will be resized to the appropriate length. 
             </remarks>
        </member>
        <member name="M:LibHac.Fs.SubStorage.#ctor">
            <summary>
            Creates an uninitialized <see cref="T:LibHac.Fs.SubStorage"/>. It must be initialized with <see cref="M:LibHac.Fs.SubStorage.InitializeFrom(LibHac.Fs.SubStorage)"/> before using.
            </summary>
        </member>
        <member name="M:LibHac.Fs.SubStorage.#ctor(LibHac.Fs.SubStorage)">
            <summary>
            Creates a copy of <paramref name="other"/>.
            <paramref name="other"/> will not be disposed when the created <see cref="T:LibHac.Fs.SubStorage"/> is disposed.
            </summary>
            <param name="other">The <see cref="T:LibHac.Fs.SubStorage"/> to create a copy of. Caller retains ownership.</param>
        </member>
        <member name="M:LibHac.Fs.SubStorage.InitializeFrom(LibHac.Fs.SubStorage)">
            <summary>
            Initializes or reinitializes this <see cref="T:LibHac.Fs.SubStorage"/> as a copy of <paramref name="other"/>.
            Any shared references in <paramref name="other"/> will be copied.
            </summary>
            <param name="other">The <see cref="T:LibHac.Fs.SubStorage"/> used to initialize this one.</param>
        </member>
        <member name="M:LibHac.Fs.SubStorage.#ctor(LibHac.Fs.IStorage,System.Int64,System.Int64)">
            <summary>
            Creates a <see cref="T:LibHac.Fs.SubStorage"/> from a subsection of another <see cref="T:LibHac.Fs.IStorage"/>.
            <paramref name="baseStorage"/> will not be disposed when the created <see cref="T:LibHac.Fs.SubStorage"/> is disposed.
            </summary>
            <param name="baseStorage">The base <see cref="T:LibHac.Fs.IStorage"/>. Caller retains ownership.</param>
            <param name="offset">The offset in the base storage at which to begin the created SubStorage.</param>
            <param name="size">The size of the SubStorage.</param>
        </member>
        <member name="M:LibHac.Fs.SubStorage.#ctor(LibHac.ReferenceCountedDisposable{LibHac.Fs.IStorage},System.Int64,System.Int64)">
            <summary>
            Creates a <see cref="T:LibHac.Fs.SubStorage"/> from a subsection of another <see cref="T:LibHac.Fs.IStorage"/>.
            Holds a reference to <paramref name="sharedBaseStorage"/> until disposed.
            </summary>
            <param name="sharedBaseStorage">The base IStorage.</param>
            <param name="offset">The offset in the base storage at which to begin the created SubStorage.</param>
            <param name="size">The size of the SubStorage.</param>
        </member>
        <member name="M:LibHac.Fs.SubStorage.#ctor(LibHac.Fs.SubStorage,System.Int64,System.Int64)">
            <summary>
            Creates a <see cref="T:LibHac.Fs.SubStorage"/> from a subsection of another <see cref="T:LibHac.Fs.SubStorage"/>.
            <paramref name="other"/> will not be disposed when the created <see cref="T:LibHac.Fs.SubStorage"/> is disposed.
            </summary>
            <remarks>
            The created SubStorage will directly use the base SubStorage of <paramref name="other"/> and will
            adjust the <paramref name="offset"/> and <paramref name="size"/> accordingly.
            This avoids the overhead of going through two SubStorage layers.
            </remarks>
            <param name="other">The base SubStorage.</param>
            <param name="offset">The offset in the base storage at which to begin the created SubStorage.</param>
            <param name="size">The size of the SubStorage.</param>
        </member>
        <member name="M:LibHac.Fs.SubStorage.SetResizable(System.Boolean)">
            <summary>
            Sets whether the <see cref="T:LibHac.Fs.SubStorage"/> is resizable or not.
            </summary>
            <param name="isResizable"><see langword="true"/> if the <see cref="T:LibHac.Fs.SubStorage"/> should
            be resizable. <see langword="false"/> if not.</param>
        </member>
        <member name="P:LibHac.HorizonResultException.ResultValue">
            <summary>
            The result code of the error.
            </summary>
        </member>
        <member name="P:LibHac.HorizonResultException.InternalResultValue">
            <summary>
            The original, internal result code if it was converted to a more general external result code.
            </summary>
        </member>
        <member name="M:LibHac.HorizonResultException.#ctor(LibHac.Result)">
            <summary>
            Initializes a new instance of the <see cref="T:LibHac.HorizonResultException"/> class. 
            </summary>
            <param name="result">The result code for the reason for the exception.</param>
        </member>
        <member name="M:LibHac.HorizonResultException.#ctor(LibHac.Result,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:LibHac.HorizonResultException"/> class with a specified error message.
            </summary>
            <param name="result">The result code for the reason for the exception.</param>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:LibHac.HorizonResultException.#ctor(LibHac.Result,System.String,System.Exception)">
            <summary>
             Initializes a new instance of the <see cref="T:LibHac.HorizonResultException"/> class with a specified error message
             and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="result">The result code for the reason for the exception.</param>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, or a null reference if no inner exception is specified.</param>
        </member>
        <member name="M:LibHac.HorizonResultException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:LibHac.MissingKeyException"/> class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/>  that contains contextual information about the source or destination.</param>
        </member>
        <member name="M:LibHac.IProgressReport.Report(System.Int64)">
            <summary>
            Sets the current value of the <see cref="T:LibHac.IProgressReport"/> to <paramref name="value"/>.
            </summary>
            <param name="value">The value to set.</param>
        </member>
        <member name="M:LibHac.IProgressReport.ReportAdd(System.Int64)">
            <summary>
            Adds <paramref name="value"/> to the current value of the <see cref="T:LibHac.IProgressReport"/>.
            </summary>
            <param name="value">The amount to add.</param>
        </member>
        <member name="M:LibHac.IProgressReport.SetTotal(System.Int64)">
            <summary>
            Sets the maximum value of the <see cref="T:LibHac.IProgressReport"/> to <paramref name="value"/>.
            </summary>
            <param name="value">The maximum value to set.</param>
        </member>
        <member name="M:LibHac.IProgressReport.LogMessage(System.String)">
            <summary>
            Logs a message to the <see cref="T:LibHac.IProgressReport"/> object.
            </summary>
            <param name="message">The message to output.</param>
        </member>
        <member name="M:LibHac.Kernel.IniExtract.TryGetIni1Offset(System.Int32@,System.Int32@,LibHac.Fs.IStorage)">
            <summary>
            Locates and returns the offset and size of the initial process binary embedded in the kernel.
            The INI is only embedded in the kernel in system versions >= 8.0.0.
            </summary>
            <param name="offset">When this method returns, contains the offset of
            the INI inside the kernel if it was found.</param>
            <param name="size">When this method returns, contains the size of the INI if it was found.</param>
            <param name="kernelStorage">An <see cref="T:LibHac.Fs.IStorage"/> containing the kernel to search.</param>
            <returns><see langword="true"/> if the embedded INI was found.</returns>
        </member>
        <member name="M:LibHac.Kernel.KipReader.GetRawData(LibHac.Fs.IStorage@)">
            <summary>
            Gets the raw input KIP file.
            </summary>
            <param name="kipData">If the operation returns successfully, an <see cref="T:LibHac.Fs.IStorage"/>
            containing the KIP data.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="F:LibHac.Keyset.UsedKeyblobCount">
            <summary>
            The number of keyblobs that were used for &lt; 6.2.0 crypto
            </summary>
        </member>
        <member name="T:LibHac.Kvdb.FlatMapKeyValueStore`1">
            <summary>
            Represents a collection of keys and values that are sorted by the key,
            and may be saved and loaded from an archive file on disk.
            </summary>
            <typeparam name="TKey">The type of the keys in the keys in the key-value store.</typeparam>
        </member>
        <member name="M:LibHac.Kvdb.FlatMapKeyValueStore`1.Initialize(LibHac.Fs.FileSystemClient,LibHac.Common.U8Span,System.Int32,LibHac.MemoryResource,LibHac.MemoryResource)">
            <summary>
            Initializes a <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1"/>. Reads and writes the store to and from the file imkvdb.arc
            in the specified <paramref name="rootPath"/> directory. This directory must exist when calling <see cref="M:LibHac.Kvdb.FlatMapKeyValueStore`1.Initialize(LibHac.Fs.FileSystemClient,LibHac.Common.U8Span,System.Int32,LibHac.MemoryResource,LibHac.MemoryResource)"/>,
            but it is not required for the imkvdb.arc file to exist.
            </summary>
            <param name="fsClient">The <see cref="T:LibHac.Fs.FileSystemClient"/> to use for reading and writing the archive.</param>
            <param name="rootPath">The directory path used to load and save the archive file. Directory must already exist.</param>
            <param name="capacity">The maximum number of entries that can be stored.</param>
            <param name="memoryResource"><see cref="T:LibHac.MemoryResource"/> for allocating buffers to hold entries and values.</param>
            <param name="autoBufferMemoryResource"><see cref="T:LibHac.MemoryResource"/> for allocating temporary buffers
            when reading and writing the store to a file.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.Kvdb.FlatMapKeyValueStore`1.Load">
            <summary>
            Clears all entries in the <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1"/> and loads all entries
            from the database archive file, if it exists.
            </summary>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.Kvdb.FlatMapKeyValueStore`1.Save">
            <summary>
            Writes all entries in the <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1"/> to a database archive file.
            </summary>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.Kvdb.FlatMapKeyValueStore`1.Get(System.Int32@,`0@,System.Span{System.Byte})">
            <summary>
            Gets the value associated with the specified key.
            </summary>
            <param name="valueSize">If the method returns successfully, contains the size of
            the value written to <paramref name="valueBuffer"/>. This may be smaller than the
            actual length of the value if <paramref name="valueBuffer"/> was not large enough.</param>
            <param name="key">The key of the value to get.</param>
            <param name="valueBuffer">If the method returns successfully, contains the value
            associated with the specified key. Otherwise, the buffer will not be modified.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
            <remarks>Possible <see cref="T:LibHac.Result"/>s:<br/>
            <see cref="P:LibHac.Kvdb.ResultKvdb.KeyNotFound"/>
            The specified key was not found in the <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1"/>.</remarks>
        </member>
        <member name="M:LibHac.Kvdb.FlatMapKeyValueStore`1.Set(`0@,System.ReadOnlySpan{System.Byte})">
            <summary>
            Adds the specified key and value to the <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1"/>.
            The existing value is replaced if the key already exists.
            </summary>
            <param name="key">The key to add.</param>
            <param name="value">The value to add.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.Kvdb.FlatMapKeyValueStore`1.Delete(`0@)">
            <summary>
            Deletes an element from the <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1"/>.
            </summary>
            <param name="key">The key of the element to delete.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
            <remarks>Possible <see cref="T:LibHac.Result"/>s:<br/>
            <see cref="P:LibHac.Kvdb.ResultKvdb.KeyNotFound"/>
            The specified key was not found in the <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1"/>.</remarks>
        </member>
        <member name="M:LibHac.Kvdb.FlatMapKeyValueStore`1.GetBeginIterator">
            <summary>
            Creates an <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1.Iterator"/> that starts at the first element in the <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1"/>.
            </summary>
            <returns>The created iterator.</returns>
        </member>
        <member name="M:LibHac.Kvdb.FlatMapKeyValueStore`1.GetLowerBoundIterator(`0@)">
            <summary>
            Creates an <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1.Iterator"/> that starts at the first element equal to or greater than
            <paramref name="key"/> in the <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1"/>.
            </summary>
            <param name="key">The key at which to begin iteration.</param>
            <returns>The created iterator.</returns>
        </member>
        <member name="M:LibHac.Kvdb.FlatMapKeyValueStore`1.FixIterator(LibHac.Kvdb.FlatMapKeyValueStore{`0}.Iterator@,`0@)">
            <summary>
            Fixes an iterator's current position and total length so that after an entry
            is added or removed, the iterator will still be on the same entry.
            </summary>
            <param name="iterator">The iterator to fix.</param>
            <param name="key">The key that was added or removed.</param>
        </member>
        <member name="M:LibHac.Kvdb.FlatMapKeyValueStore`1.ReadArchive(LibHac.Kvdb.AutoBuffer@)">
            <summary>
            Reads the database archive file into the provided buffer.
            </summary>
            <param name="buffer">The buffer the file will be read into.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.Kvdb.FlatMapKeyValueStore`1.LoadFrom(System.ReadOnlySpan{System.Byte})">
            <summary>
            Loads all key-value pairs from a key-value archive.
            All keys in the archive are assumed to be in ascending order.
            </summary>
            <param name="buffer">The buffer containing the key-value archive.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="T:LibHac.Kvdb.FlatMapKeyValueStore`1.KeyValue">
            <summary>
            Represents a key-value pair contained in a <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1"/>.
            </summary>
        </member>
        <member name="T:LibHac.Kvdb.FlatMapKeyValueStore`1.Index">
            <summary>
            Manages the sorted list of <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1.KeyValue"/> entries in a <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1"/>.
            </summary>
        </member>
        <member name="P:LibHac.Kvdb.FlatMapKeyValueStore`1.Index.Count">
            <summary>
            The number of elements currently in the <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1.Index"/>.
            </summary>
        </member>
        <member name="M:LibHac.Kvdb.FlatMapKeyValueStore`1.Index.Initialize(System.Int32,LibHac.MemoryResource)">
            <summary>
            Initializes the <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1.Index"/>
            </summary>
            <param name="capacity">The maximum number of elements the <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1.Index"/> will be able to hold.</param>
            <param name="memoryResource">The <see cref="T:LibHac.MemoryResource"/> that will be used to allocate
            memory for values added to the <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1.Index"/>.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.Kvdb.FlatMapKeyValueStore`1.Index.Set(`0@,System.ReadOnlySpan{System.Byte})">
            <summary>
            Adds the specified key and value to the <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1.Index"/>.
            The existing value is replaced if the key already exists.
            </summary>
            <param name="key">The key to add.</param>
            <param name="value">The value to add.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.Kvdb.FlatMapKeyValueStore`1.Index.AppendUnsafe(`0@,LibHac.MemoryResource.Buffer)">
            <summary>
            Adds the specified key and value to the end of the list.
            Does not verify that the list will be sorted properly. The caller must make sure the sorting will be correct.
            Used when populating a new <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1.Index"/> with already sorted entries.
            </summary>
            <param name="key">The key to add.</param>
            <param name="value">The value to add.</param>
            <returns>The <see cref="T:LibHac.Result"/> of the operation.</returns>
        </member>
        <member name="M:LibHac.Kvdb.FlatMapKeyValueStore`1.Index.Clear">
            <summary>
            Removes all keys and values from the <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1.Index"/>.
            </summary>
        </member>
        <member name="M:LibHac.Kvdb.FlatMapKeyValueStore`1.Index.Delete(`0@)">
            <summary>
            Deletes an element from the <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1.Index"/>.
            </summary>
            <param name="key">The key of the element to delete.</param>
            <returns><see langword="true"/> if the item was found and deleted.
            <see langword="false"/> if the key was not in the store.</returns>
        </member>
        <member name="M:LibHac.Kvdb.FlatMapKeyValueStore`1.Index.GetBeginIterator">
            <summary>
            Returns an iterator starting at the first element in the <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1.Index"/>.
            </summary>
            <returns>The created iterator.</returns>
        </member>
        <member name="M:LibHac.Kvdb.FlatMapKeyValueStore`1.Index.GetBeginConstIterator">
            <summary>
            Returns a read-only iterator starting at the first element in the <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1.Index"/>.
            </summary>
            <returns>The created iterator.</returns>
        </member>
        <member name="M:LibHac.Kvdb.FlatMapKeyValueStore`1.Index.GetLowerBoundIterator(`0@)">
            <summary>
            Returns an iterator starting at the first element greater than or equal to <paramref name="key"/>.
            </summary>
            <param name="key">The key at which to begin iteration.</param>
            <returns>The created iterator.</returns>
        </member>
        <member name="M:LibHac.Kvdb.FlatMapKeyValueStore`1.Index.GetLowerBoundConstIterator(`0@)">
            <summary>
            Returns a read-only iterator starting at the first element greater than or equal to <paramref name="key"/>.
            </summary>
            <param name="key">The key at which to begin iteration.</param>
            <returns>The created iterator.</returns>
        </member>
        <member name="M:LibHac.Kvdb.FlatMapKeyValueStore`1.Index.FixIterator(LibHac.Kvdb.FlatMapKeyValueStore{`0}.Iterator@,`0@)">
            <summary>
            Fixes an iterator's current position and total length so that after an entry
            is added or removed, the iterator will still be on the same entry.
            </summary>
            <param name="iterator">The iterator to fix.</param>
            <param name="key">The key that was added or removed.</param>
        </member>
        <member name="T:LibHac.Kvdb.FlatMapKeyValueStore`1.Iterator">
            <summary>
            Iterates through the elements in a <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1"/>.
            </summary>
        </member>
        <member name="M:LibHac.Kvdb.FlatMapKeyValueStore`1.Iterator.Fix(System.Int32,System.Int32)">
            <summary>
            Fixes the iterator current position and total length so that after an entry
            is added or removed, the iterator will still be on the same entry.
            </summary>
            <param name="entryIndex">The index of the added or removed entry.</param>
            <param name="newLength">The new length of the list.</param>
            <remarks></remarks>
        </member>
        <member name="T:LibHac.Kvdb.FlatMapKeyValueStore`1.ConstIterator">
            <summary>
            Iterates through the elements in a <see cref="T:LibHac.Kvdb.FlatMapKeyValueStore`1"/>.
            </summary>
        </member>
        <member name="P:LibHac.Kvdb.ResultKvdb.OutOfKeyResource">
            <summary>There is no more space in the database or the key is too long.<br/>Error code: 2020-0001; Inner value: 0x214</summary>
        </member>
        <member name="P:LibHac.Kvdb.ResultKvdb.KeyNotFound">
            <summary>Error code: 2020-0002; Inner value: 0x414</summary>
        </member>
        <member name="P:LibHac.Kvdb.ResultKvdb.AllocationFailed">
            <summary>Error code: 2020-0004; Inner value: 0x814</summary>
        </member>
        <member name="P:LibHac.Kvdb.ResultKvdb.InvalidKeyValue">
            <summary>Error code: 2020-0005; Inner value: 0xa14</summary>
        </member>
        <member name="P:LibHac.Kvdb.ResultKvdb.BufferInsufficient">
            <summary>Error code: 2020-0006; Inner value: 0xc14</summary>
        </member>
        <member name="T:LibHac.LibHacException">
            <summary>
            This is the exception that is thrown when an error occurs 
            </summary>
        </member>
        <member name="M:LibHac.LibHacException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:LibHac.LibHacException"/> class. 
            </summary>
        </member>
        <member name="M:LibHac.LibHacException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:LibHac.LibHacException"/> class with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:LibHac.LibHacException.#ctor(System.String,System.Exception)">
            <summary>
             Initializes a new instance of the <see cref="T:LibHac.LibHacException"/> class with a specified error message
             and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, or a null reference if no inner exception is specified.</param>
        </member>
        <member name="M:LibHac.LibHacException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:LibHac.LibHacException"/> class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/>  that contains contextual information about the source or destination.</param>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.TooLongArgument">
            <summary>Error code: 2009-0001; Inner value: 0x209</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.TooManyArguments">
            <summary>Error code: 2009-0002; Inner value: 0x409</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.TooLargeMeta">
            <summary>Error code: 2009-0003; Inner value: 0x609</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.InvalidMeta">
            <summary>Error code: 2009-0004; Inner value: 0x809</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.InvalidNso">
            <summary>Error code: 2009-0005; Inner value: 0xa09</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.InvalidPath">
            <summary>Error code: 2009-0006; Inner value: 0xc09</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.TooManyProcesses">
            <summary>Error code: 2009-0007; Inner value: 0xe09</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.NotPinned">
            <summary>Error code: 2009-0008; Inner value: 0x1009</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.InvalidProgramId">
            <summary>Error code: 2009-0009; Inner value: 0x1209</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.InvalidVersion">
            <summary>Error code: 2009-0010; Inner value: 0x1409</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.InsufficientAddressSpace">
            <summary>Error code: 2009-0051; Inner value: 0x6609</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.InvalidNro">
            <summary>Error code: 2009-0052; Inner value: 0x6809</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.InvalidNrr">
            <summary>Error code: 2009-0053; Inner value: 0x6a09</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.InvalidSignature">
            <summary>Error code: 2009-0054; Inner value: 0x6c09</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.InsufficientNroRegistrations">
            <summary>Error code: 2009-0055; Inner value: 0x6e09</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.InsufficientNrrRegistrations">
            <summary>Error code: 2009-0056; Inner value: 0x7009</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.NroAlreadyLoaded">
            <summary>Error code: 2009-0057; Inner value: 0x7209</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.InvalidAddress">
            <summary>Error code: 2009-0081; Inner value: 0xa209</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.InvalidSize">
            <summary>Error code: 2009-0082; Inner value: 0xa409</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.NotLoaded">
            <summary>Error code: 2009-0084; Inner value: 0xa809</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.NotRegistered">
            <summary>Error code: 2009-0085; Inner value: 0xaa09</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.InvalidSession">
            <summary>Error code: 2009-0086; Inner value: 0xac09</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.InvalidProcess">
            <summary>Error code: 2009-0087; Inner value: 0xae09</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.UnknownCapability">
            <summary>Error code: 2009-0100; Inner value: 0xc809</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.InvalidCapabilityKernelFlags">
            <summary>Error code: 2009-0103; Inner value: 0xce09</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.InvalidCapabilitySyscallMask">
            <summary>Error code: 2009-0104; Inner value: 0xd009</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.InvalidCapabilityMapRange">
            <summary>Error code: 2009-0106; Inner value: 0xd409</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.InvalidCapabilityMapPage">
            <summary>Error code: 2009-0107; Inner value: 0xd609</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.InvalidCapabilityInterruptPair">
            <summary>Error code: 2009-0111; Inner value: 0xde09</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.InvalidCapabilityApplicationType">
            <summary>Error code: 2009-0113; Inner value: 0xe209</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.InvalidCapabilityKernelVersion">
            <summary>Error code: 2009-0114; Inner value: 0xe409</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.InvalidCapabilityHandleTable">
            <summary>Error code: 2009-0115; Inner value: 0xe609</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.InvalidCapabilityDebugFlags">
            <summary>Error code: 2009-0116; Inner value: 0xe809</summary>
        </member>
        <member name="P:LibHac.Loader.ResultLoader.InternalError">
            <summary>Error code: 2009-0200; Inner value: 0x19009</summary>
        </member>
        <member name="T:LibHac.MemoryResource.Buffer">
            <summary>
            Represents a region of memory allocated by a <see cref="T:LibHac.MemoryResource"/>.
            </summary>
        </member>
        <member name="P:LibHac.MemoryResource.Buffer.Extra">
            <summary>
            A field where <see cref="T:LibHac.MemoryResource"/> implementers can store info about the <see cref="T:LibHac.MemoryResource.Buffer"/>.
            </summary>
        </member>
        <member name="P:LibHac.MemoryResource.Buffer.Length">
            <summary>
            The length of the buffer in bytes.
            </summary>
        </member>
        <member name="M:LibHac.MemoryResource.Buffer.Get">
            <summary>
            Gets a span from the <see cref="T:LibHac.MemoryResource.Buffer"/>.
            </summary>
        </member>
        <member name="P:LibHac.MemoryResource.Buffer.IsValid">
            <summary>
            Returns <see langword="true"/> if the <see cref="T:LibHac.MemoryResource.Buffer"/> is valid.
            </summary>
        </member>
        <member name="T:LibHac.MissingKeyException">
            <summary>
            This is the exception that is thrown when an action requires a key that is not found in the provided keyset.
            </summary>
        </member>
        <member name="P:LibHac.MissingKeyException.Name">
            <summary>
            The name of the key that is missing.
            </summary>
        </member>
        <member name="P:LibHac.MissingKeyException.Type">
            <summary>
            The type of the key that is missing.
            </summary>
        </member>
        <member name="M:LibHac.MissingKeyException.#ctor(System.String,System.String,LibHac.KeyType)">
            <summary>
             Initializes a new instance of the <see cref="T:LibHac.MissingKeyException"/> class with a specified error message,
             information about the missing key and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="name">The name of the key that is missing, or the rights ID of the missing key if <paramref name="keyType"/> is <see cref="F:LibHac.KeyType.Title"/></param>
            <param name="keyType">The <see cref="T:LibHac.KeyType"/> of the key that is missing.</param>
        </member>
        <member name="M:LibHac.MissingKeyException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:LibHac.MissingKeyException"/> class. 
            </summary>
        </member>
        <member name="M:LibHac.MissingKeyException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:LibHac.MissingKeyException"/> class with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:LibHac.MissingKeyException.#ctor(System.String,System.Exception)">
            <summary>
             Initializes a new instance of the <see cref="T:LibHac.MissingKeyException"/> class with a specified error message
             and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception, or a null reference if no inner exception is specified.</param>
        </member>
        <member name="M:LibHac.MissingKeyException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:LibHac.MissingKeyException"/> class with serialized data.
            </summary>
            <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo"/> that holds the serialized object data about the exception being thrown.</param>
            <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext"/>  that contains contextual information about the source or destination.</param>
        </member>
        <member name="T:LibHac.ReferenceCountedDisposable`1">
             <summary>
             A reference-counting wrapper which allows multiple uses of a single disposable object in code, which is
             deterministically released (by calling <see cref="M:System.IDisposable.Dispose"/>) when the last reference is
             disposed.
             </summary>
             <remarks>
             <para>Each instance of <see cref="T:LibHac.ReferenceCountedDisposable`1"/> represents a counted reference (also
             referred to as a <em>reference</em> in the following documentation) to a target object. Each of these
             references has a lifetime, starting when it is constructed and continuing through its release. During
             this time, the reference is considered <em>alive</em>. Each reference which is alive owns exactly one
             reference to the target object, ensuring that it will not be disposed while still in use. A reference is
             released through either of the following actions:</para>
            
             <list type="bullet">
             <item>The reference is explicitly released by a call to <see cref="M:LibHac.ReferenceCountedDisposable`1.Dispose"/>.</item>
             <item>The reference is no longer in use by managed code and gets reclaimed by the garbage collector.</item>
             </list>
            
             <para>While each instance of <see cref="T:LibHac.ReferenceCountedDisposable`1"/> should be explicitly disposed when
             the object is no longer needed by the code owning the reference, this implementation will not leak resources
             in the event one or more callers fail to do so. When all references to an object are explicitly released
             (i.e. by calling <see cref="M:LibHac.ReferenceCountedDisposable`1.Dispose"/>), the target object will itself be deterministically released by a
             call to <see cref="M:System.IDisposable.Dispose"/> when the last reference to it is released. However, in the event
             one or more references is not explicitly released, the underlying object will still become eligible for
             non-deterministic release (i.e. finalization) as soon as each reference to it is released by one of the
             two actions described previously.</para>
            
             <para>When using <see cref="T:LibHac.ReferenceCountedDisposable`1"/>, certain steps must be taken to ensure the
             target object is not disposed early.</para>
            
             <list type="number">
             <para>Use <see cref="T:LibHac.ReferenceCountedDisposable`1"/> consistently. In other words, do not mix code using
             reference-counted wrappers with code that references to the target directly.</para>
             <para>Only use the <see cref="M:LibHac.ReferenceCountedDisposable`1.#ctor(`0)"/> constructor one time per target object.
             Additional references to the same target object must only be obtained by calling
             <see cref="M:LibHac.ReferenceCountedDisposable`1.TryAddReference"/>.</para>
             <para>Do not call <see cref="M:System.IDisposable.Dispose"/> on the target object directly. It will be called
             automatically at the appropriate time, as described above.</para>
             </list>
            
             <para>All public methods on this type adhere to their pre- and post-conditions and will not invalidate state
             even in concurrent execution.</para>
             </remarks>
             <typeparam name="T">The type of disposable object.</typeparam>
        </member>
        <member name="F:LibHac.ReferenceCountedDisposable`1._instance">
            <summary>
            The target of this reference. This value is initialized to a non-<see langword="null"/> value in the
            constructor, and set to <see langword="null"/> when the current reference is disposed.
            </summary>
            <remarks>
            <para>This value is only cleared in order to support cases where one or more references is garbage
            collected without having <see cref="M:LibHac.ReferenceCountedDisposable`1.Dispose"/> called.</para>
            </remarks>
        </member>
        <member name="F:LibHac.ReferenceCountedDisposable`1._boxedReferenceCount">
             <summary>
             The boxed reference count, which is shared by all references with the same <see cref="P:LibHac.ReferenceCountedDisposable`1.Target"/> object.
             </summary>
             <remarks>
             <para>This field serves as the synchronization object for the current type, since it is shared among all
             counted reference to the same target object. Accesses to <see cref="F:System.Runtime.CompilerServices.StrongBox`1.Value"/> should only
             occur when this object is locked.</para>
            
             <para>PERF DEV NOTE: A concurrent (but complex) implementation of this type with identical semantics is
             available in source control history. The use of exclusive locks was not causing any measurable
             performance overhead even on 28-thread machines at the time this was written.</para>
             </remarks>
        </member>
        <member name="M:LibHac.ReferenceCountedDisposable`1.#ctor(`0)">
            <summary>
            Initializes a new reference counting wrapper around an <see cref="T:System.IDisposable"/> object.
            </summary>
            <remarks>
            <para>The reference count is initialized to 1.</para>
            </remarks>
            <param name="instance">The object owned by this wrapper.</param>
            <exception cref="T:System.ArgumentNullException">
            If <paramref name="instance"/> is <see langword="null"/>.
            </exception>
        </member>
        <member name="P:LibHac.ReferenceCountedDisposable`1.Target">
            <summary>
            Gets the target object.
            </summary>
            <remarks>
            <para>This call is not valid after <see cref="M:LibHac.ReferenceCountedDisposable`1.Dispose"/> is called. If this property or the target
            object is used concurrently with a call to <see cref="M:LibHac.ReferenceCountedDisposable`1.Dispose"/>, it is possible for the code to be
            using a disposed object. After the current instance is disposed, this property throws
            <see cref="T:System.ObjectDisposedException"/>. However, the exact time when this property starts throwing after
            <see cref="M:LibHac.ReferenceCountedDisposable`1.Dispose"/> is called is unspecified; code is expected to not use this property or the object
            it returns after any code invokes <see cref="M:LibHac.ReferenceCountedDisposable`1.Dispose"/>.</para>
            </remarks>
            <value>The target object.</value>
        </member>
        <member name="M:LibHac.ReferenceCountedDisposable`1.AddReference">
            <summary>
            Increments the reference count for the disposable object, and returns a new disposable reference to it.
            </summary>
            <remarks>
            <para>The returned object is an independent reference to the same underlying object. Disposing of the
            returned value multiple times will only cause the reference count to be decreased once.</para>
            </remarks>
            <returns>A new <see cref="T:LibHac.ReferenceCountedDisposable`1"/> pointing to the same underlying object, if it
            has not yet been disposed; otherwise, <see cref="T:System.ObjectDisposedException"/> is thrown if this reference
            to the underlying object has already been disposed.</returns>
        </member>
        <member name="M:LibHac.ReferenceCountedDisposable`1.AddReference``1">
            <summary>
            Increments the reference count for the disposable object, and returns a new disposable reference to it
            of type <typeparamref name="TTo"/>. The type of the disposable object must be compatible with type
            <typeparamref name="TTo"/>.
            </summary>
            <remarks>
            <para>The returned object is an independent reference to the same underlying object. Disposing of the
            returned value multiple times will only cause the reference count to be decreased once.</para>
            </remarks>
            <typeparam name="TTo">The type of the new reference to the disposable object.</typeparam>
            <returns>A new <see cref="T:LibHac.ReferenceCountedDisposable`1"/> pointing to the same underlying object, if it
            has not yet been disposed; otherwise, <see cref="T:System.ObjectDisposedException"/> is thrown if this reference
            to the underlying object has already been disposed, and <see cref="T:System.InvalidCastException"/> is thrown if
            <typeparamref name="T"/> is not compatible with <typeparamref name="TTo"/>.</returns>
        </member>
        <member name="M:LibHac.ReferenceCountedDisposable`1.TryAddReference``1">
            <summary>
            Increments the reference count for the disposable object, and returns a new disposable reference to it
            of type <typeparamref name="TTo"/>. The type of the disposable object must be compatible with type
            <typeparamref name="TTo"/>.
            </summary>
            <remarks>
            <para>The returned object is an independent reference to the same underlying object. Disposing of the
            returned value multiple times will only cause the reference count to be decreased once.</para>
            </remarks>
            <returns>A new <see cref="T:LibHac.ReferenceCountedDisposable`1"/> pointing to the same underlying object, if it
            has not yet been disposed, and <typeparamref name="T"/> is compatible with <typeparamref name="TTo"/>;
            otherwise, <see langword="null"/> if this reference to the underlying object has already been disposed.
            </returns>
        </member>
        <member name="M:LibHac.ReferenceCountedDisposable`1.TryAddReference">
            <summary>
            Increments the reference count for the disposable object, and returns a new disposable reference to it.
            </summary>
            <remarks>
            <para>The returned object is an independent reference to the same underlying object. Disposing of the
            returned value multiple times will only cause the reference count to be decreased once.</para>
            </remarks>
            <returns>A new <see cref="T:LibHac.ReferenceCountedDisposable`1"/> pointing to the same underlying object, if it
            has not yet been disposed; otherwise, <see langword="null"/> if this reference to the underlying object
            has already been disposed.</returns>
        </member>
        <member name="M:LibHac.ReferenceCountedDisposable`1.TryAddReferenceImpl(`0,System.Runtime.CompilerServices.StrongBox{System.Int32})">
            <summary>
            Provides the implementation for <see cref="M:LibHac.ReferenceCountedDisposable`1.TryAddReference"/> and
            <see cref="M:LibHac.ReferenceCountedDisposable`1.WeakReference.TryAddReference"/>.
            </summary>
        </member>
        <member name="M:LibHac.ReferenceCountedDisposable`1.TryAddReferenceImpl``2(``0,System.Runtime.CompilerServices.StrongBox{System.Int32},LibHac.ReferenceCountedDisposable{`0}.CreateResult@)">
            <summary>
            Provides the implementation for <see cref="M:LibHac.ReferenceCountedDisposable`1.TryAddReference"/> and
            <see cref="M:LibHac.ReferenceCountedDisposable`1.WeakReference.TryAddReference"/> when casting the underlying object to another type.
            </summary>
        </member>
        <member name="M:LibHac.ReferenceCountedDisposable`1.Dispose">
            <summary>
            Releases the current reference, causing the underlying object to be disposed if this was the last
            reference.
            </summary>
            <remarks>
            <para>After this instance is disposed, the <see cref="M:LibHac.ReferenceCountedDisposable`1.TryAddReference"/> method can no longer be used to
            object a new reference to the target, even if other references to the target object are still in
            use.</para>
            </remarks>
        </member>
        <member name="T:LibHac.ReferenceCountedDisposable`1.CreateResult">
            <summary>
            Represents the result of the TryAddReferenceImpl method.
            </summary>
        </member>
        <member name="T:LibHac.ReferenceCountedDisposable`1.WeakReference">
            <summary>
            Represents a weak reference to a <see cref="T:LibHac.ReferenceCountedDisposable`1"/> which is capable of
            obtaining a new counted reference up until the point when the object is no longer accessible.
            </summary>
        </member>
        <member name="F:LibHac.ReferenceCountedDisposable`1.WeakReference._weakInstance">
            <summary>
            DO NOT DISPOSE OF THE TARGET.
            </summary>
        </member>
        <member name="M:LibHac.ReferenceCountedDisposable`1.WeakReference.TryAddReference">
             <summary>
             Increments the reference count for the disposable object, and returns a new disposable reference to
             it.
             </summary>
             <remarks>
             <para>Unlike <see cref="M:LibHac.ReferenceCountedDisposable`1.TryAddReference"/>, this method is capable of
             adding a reference to the underlying instance all the way up to the point where it is finally
             disposed.</para>
            
             <para>The returned object is an independent reference to the same underlying object. Disposing of
             the returned value multiple times will only cause the reference count to be decreased once.</para>
             </remarks>
             <returns>A new <see cref="T:LibHac.ReferenceCountedDisposable`1"/> pointing to the same underlying object,
             if it has not yet been disposed; otherwise, <see langword="null"/> if the underlying object has
             already been disposed.</returns>
        </member>
        <member name="T:LibHac.Result">
            <summary>
            Represents a code used to report the result of a returned function.
            </summary>
        </member>
        <member name="P:LibHac.Result.Success">
            <summary>
            The <see cref="T:LibHac.Result"/> signifying success.
            </summary>
        </member>
        <member name="M:LibHac.Result.#ctor(System.UInt32)">
            <summary>
            Creates a new <see cref="T:LibHac.Result"/> from the internal result value.
            </summary>
            <param name="value">The value used internally by <see cref="T:LibHac.Result"/>.</param>
        </member>
        <member name="M:LibHac.Result.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new <see cref="T:LibHac.Result"/> from a module and description.
            </summary>
            <param name="module">The module this result is from. Must be in the range 1 through 511.</param>
            <param name="description">The description value of the result. Must be in the range 0 through 8191.</param>
        </member>
        <member name="M:LibHac.Result.IgnoreResult">
            <summary>
            Specifies that the <see cref="T:LibHac.Result"/> from a returned function is explicitly ignored.
            </summary>
        </member>
        <member name="M:LibHac.Result.Log">
            <summary>
            Performs no action in release mode.
            In debug mode, logs returned results using the <see cref="T:LibHac.Result.IResultLogger"/> set by <see cref="M:LibHac.Result.SetLogger(LibHac.Result.IResultLogger)"/>.
            <br/>Intended to always be used when returning a non-zero <see cref="T:LibHac.Result"/>.
            <br/><br/>Example:
            <code>return result.Log();</code>
            </summary>
            <returns>The called <see cref="T:LibHac.Result"/> value.</returns>
        </member>
        <member name="M:LibHac.Result.LogConverted(LibHac.Result)">
            <summary>
            In debug mode, logs converted results using the <see cref="T:LibHac.Result.IResultLogger"/> set by <see cref="M:LibHac.Result.SetLogger(LibHac.Result.IResultLogger)"/>.
            </summary>
            <param name="originalResult">The original <see cref="T:LibHac.Result"/> value.</param>
            <returns>The called <see cref="T:LibHac.Result"/> value.</returns>
        </member>
        <member name="M:LibHac.Result.ToStringWithName">
            <summary>
            If a <see cref="T:LibHac.Result.IResultNameResolver"/> has been set via <see cref="M:LibHac.Result.SetNameResolver(LibHac.Result.IResultNameResolver)"/>, attempts to
            return the name and error code of this <see cref="T:LibHac.Result"/>, otherwise it only returns <see cref="P:LibHac.Result.ErrorCode"/>.
            </summary>
            <returns>If a name was found, the name and error code, otherwise just the error code.</returns>
        </member>
        <member name="M:LibHac.Result.SetLogger(LibHac.Result.IResultLogger)">
            <summary>
            Sets a <see cref="T:LibHac.Result.IResultLogger"/> to be called when <see cref="M:LibHac.Result.Log"/> is called in debug mode.
            </summary>
        </member>
        <member name="M:LibHac.Result.SetNameResolver(LibHac.Result.IResultNameResolver)">
            <summary>
            Sets a <see cref="T:LibHac.Result.IResultNameResolver"/> that will be used by methods like <see cref="M:LibHac.Result.ToStringWithName"/>
            or <see cref="M:LibHac.Result.TryGetResultName(System.String@)"/> to resolve the names of <see cref="T:LibHac.Result"/>s.
            </summary>
        </member>
        <member name="T:LibHac.Result.Base">
             <summary>
             Represents a range of <see cref="T:LibHac.Result"/>s.
             This range is defined by a single module value and a range of description values.
             See the documentation remarks for additional information.
             </summary>
             <remarks>
             Due to C# not having templates, we can't define results like Horizon and Atmosphere do.
             Compared to those Result classes, this struct generates identical code and uses identical syntax.
             <br/>A Result definition should look like this: <c>public static Result.Base PathNotFound => new Result.Base(ModuleFs, 1);</c>
             <br/>Being a computed property like this will allow the compiler to do constant propagation to optimize comparisons.
             <br/><br/>This is an example of how a Result should be returned from a function: <c>return PathNotFound.Log();</c>
             <br/>The <see cref="M:LibHac.Result.Base.Log"/> method will return the <see cref="T:LibHac.Result"/> for the specified <see cref="T:LibHac.Result.Base"/>, and
             will optionally log the returned Result when running in debug mode for easier debugging. All Result logging functionality
             is removed from release builds.
             If the <see cref="T:LibHac.Result"/> is not being used as a return value, <see cref="P:LibHac.Result.Base.Value"/> will get the Result without logging anything.
             <br/><br/><see cref="M:LibHac.Result.Base.Includes(LibHac.Result)"/> is used to check if a provided <see cref="T:LibHac.Result"/> is contained within the range of the <see cref="T:LibHac.Result.Base"/>.
             If the <see cref="T:LibHac.Result.Base"/> is a computed property as shown above, the compiler will be able to properly optimize the code.
             The following pairs of lines will produce the same code given <c>Result result;</c>
             <code>
             bool a1 = ResultFs.TargetNotFound.Includes(result); // Comparing a single value
             bool a2 = result.Value == 0x7D402;
            
             bool b1 = ResultFs.InsufficientFreeSpace.Includes(result); // Comparing a range of values
             bool b2 = return result.Module == 2 &amp;&amp; (result.Description - 30 &lt;= 45 - 30);
             </code>
             Unfortunately RyuJIT will not automatically inline the property when the compiled CIL is 16 bytes or larger as in cases like
             <c>new Result.Base(ModuleFs, 2000, 2499)</c>. The property will need to have the aggressive inlining flag set like so:
             <c>public static Result.Base SdCardAccessFailed { [MethodImpl(MethodImplOptions.AggressiveInlining)] get =&gt; new Result.Base(ModuleFs, 2000, 2499); }</c>
             </remarks>
        </member>
        <member name="M:LibHac.Result.Base.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a Result <see cref="T:LibHac.Result.Base"/> containing a single value.
            </summary>
            <param name="module">The module this result is from. Must be in the range 1 through 511.</param>
            <param name="description">The description value of the result. Must be in the range 0 through 8191.</param>
        </member>
        <member name="M:LibHac.Result.Base.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>
            Creates a Result <see cref="T:LibHac.Result.Base"/> containing a range of values.
            </summary>
            <param name="module">The module this result is from. Must be in the range 1 through 511.</param>
            <param name="descriptionStart">The inclusive start description value of the range. Must be in the range 0 through 8191.</param>
            <param name="descriptionEnd">The inclusive end description value of the range. Must be in the range 0 through 8191.</param>
        </member>
        <member name="P:LibHac.Result.Base.Value">
            <summary>
            The <see cref="T:LibHac.Result"/> representing the start of this result range.
            If returning a <see cref="T:LibHac.Result"/> from a function, use <see cref="M:LibHac.Result.Base.Log"/> instead.
            </summary>
        </member>
        <member name="M:LibHac.Result.Base.Includes(LibHac.Result)">
            <summary>
            Checks if the range of this <see cref="T:LibHac.Result.Base"/> includes the provided <see cref="T:LibHac.Result"/>.
            </summary>
            <param name="result">The <see cref="T:LibHac.Result"/> to check.</param>
            <returns><see langword="true"/> if the range includes <paramref name="result"/>. Otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:LibHac.Result.Base.Log">
            <summary>
            Performs no action in release mode.
            In debug mode, logs returned results using the <see cref="T:LibHac.Result.IResultLogger"/> set by <see cref="M:LibHac.Result.SetLogger(LibHac.Result.IResultLogger)"/>.
            <br/>Intended to always be used when returning a non-zero <see cref="T:LibHac.Result"/>.
            <br/><br/>Example:
            <code>return ResultFs.PathNotFound.Log();</code>
            </summary>
            <returns>The <see cref="T:LibHac.Result"/> representing the start of this result range.</returns>
        </member>
        <member name="M:LibHac.Result.Base.LogConverted(LibHac.Result)">
            <summary>
            In debug mode, logs converted results using the <see cref="T:LibHac.Result.IResultLogger"/> set by <see cref="M:LibHac.Result.SetLogger(LibHac.Result.IResultLogger)"/>.
            </summary>
            <param name="originalResult">The original <see cref="T:LibHac.Result"/> value.</param>
            <returns>The <see cref="T:LibHac.Result"/> representing the start of this result range.</returns>
        </member>
        <member name="P:LibHac.Sf.ResultSf.NotSupported">
            <summary>Error code: 2010-0001; Inner value: 0x20a</summary>
        </member>
        <member name="P:LibHac.Sf.ResultSf.PreconditionViolation">
            <summary>Error code: 2010-0003; Inner value: 0x60a</summary>
        </member>
        <member name="P:LibHac.Sf.ResultSf.InvalidHeaderSize">
            <summary>Error code: 2010-0202; Inner value: 0x1940a</summary>
        </member>
        <member name="P:LibHac.Sf.ResultSf.InvalidInHeader">
            <summary>Error code: 2010-0211; Inner value: 0x1a60a</summary>
        </member>
        <member name="P:LibHac.Sf.ResultSf.UnknownCommandId">
            <summary>Error code: 2010-0221; Inner value: 0x1ba0a</summary>
        </member>
        <member name="P:LibHac.Sf.ResultSf.InvalidOutRawSize">
            <summary>Error code: 2010-0232; Inner value: 0x1d00a</summary>
        </member>
        <member name="P:LibHac.Sf.ResultSf.InvalidNumInObjects">
            <summary>Error code: 2010-0235; Inner value: 0x1d60a</summary>
        </member>
        <member name="P:LibHac.Sf.ResultSf.InvalidNumOutObjects">
            <summary>Error code: 2010-0236; Inner value: 0x1d80a</summary>
        </member>
        <member name="P:LibHac.Sf.ResultSf.InvalidInObject">
            <summary>Error code: 2010-0239; Inner value: 0x1de0a</summary>
        </member>
        <member name="P:LibHac.Sf.ResultSf.TargetNotFound">
            <summary>Error code: 2010-0261; Inner value: 0x20a0a</summary>
        </member>
        <member name="P:LibHac.Sf.ResultSf.OutOfDomainEntries">
            <summary>Error code: 2010-0301; Inner value: 0x25a0a</summary>
        </member>
        <member name="P:LibHac.Sf.ResultSf.RequestContextChanged">
            <summary>Error code: 2010-0800; Range: 800-899; Inner value: 0x6400a</summary>
        </member>
        <member name="P:LibHac.Sf.ResultSf.RequestInvalidated">
            <summary>Error code: 2010-0801; Range: 801-809; Inner value: 0x6420a</summary>
        </member>
        <member name="P:LibHac.Sf.ResultSf.RequestInvalidatedByUser">
            <summary>Error code: 2010-0802; Inner value: 0x6440a</summary>
        </member>
        <member name="P:LibHac.Sf.ResultSf.RequestDeferred">
            <summary>Error code: 2010-0811; Range: 811-819; Inner value: 0x6560a</summary>
        </member>
        <member name="P:LibHac.Sf.ResultSf.RequestDeferredByUser">
            <summary>Error code: 2010-0812; Inner value: 0x6580a</summary>
        </member>
        <member name="P:LibHac.Sm.ResultSm.OutOfProcesses">
            <summary>Error code: 2021-0001; Inner value: 0x215</summary>
        </member>
        <member name="P:LibHac.Sm.ResultSm.InvalidClient">
            <summary>Error code: 2021-0002; Inner value: 0x415</summary>
        </member>
        <member name="P:LibHac.Sm.ResultSm.OutOfSessions">
            <summary>Error code: 2021-0003; Inner value: 0x615</summary>
        </member>
        <member name="P:LibHac.Sm.ResultSm.AlreadyRegistered">
            <summary>Error code: 2021-0004; Inner value: 0x815</summary>
        </member>
        <member name="P:LibHac.Sm.ResultSm.OutOfServices">
            <summary>Error code: 2021-0005; Inner value: 0xa15</summary>
        </member>
        <member name="P:LibHac.Sm.ResultSm.InvalidServiceName">
            <summary>Error code: 2021-0006; Inner value: 0xc15</summary>
        </member>
        <member name="P:LibHac.Sm.ResultSm.NotRegistered">
            <summary>Error code: 2021-0007; Inner value: 0xe15</summary>
        </member>
        <member name="P:LibHac.Sm.ResultSm.NotAllowed">
            <summary>Error code: 2021-0008; Inner value: 0x1015</summary>
        </member>
        <member name="P:LibHac.Sm.ResultSm.TooLargeAccessControl">
            <summary>Error code: 2021-0009; Inner value: 0x1215</summary>
        </member>
    </members>
</doc>
